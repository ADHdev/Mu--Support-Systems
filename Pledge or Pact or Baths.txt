== SETUP ====

@create Blood Bather Baths <bbb>=10
@set bbb=inherit safe
@Desc Blood Bather Baths <bbb>=Num baths: [attrcnt([u(d.database)]/element.*)]


@create Blood Bath Database <bbd>=10
@set bbd=safe


--------------------------------------------------------------------------------
-- Optional: Code Object Data Parent -------------------------------------------

@parent bbb=codp

&prefix.elements bbb=element.
&prefix.filters bbb=fil.
&prefix.displays bbb=display.
&prefix.cross-platform bbb=_


================================================================================
== DATA ========================================================================


--------------------------------------------------------------------------------
-- Data: Basic -----------------------------------------------------------------

@fo me=&d.database bbb=num(Blood Bath Database <bbd>)



================================================================================
== CROSS-PLATFORM FUNCTIONS ====================================================

&_header bbb=u(_header, %0)
&_divider bbb=u(_divider, %0)
&_footer bbb=u(_footer, %0)

&_isapproved bbb=isapproved(%0)

&_alert bbb=[ansi(r, >%b, nh, %0, nr, %b<)] %1


================================================================================
== ELEMENTS ====================================================================

Position is: <element name> <attribute prefix> <list position>
Validation takes: %0 - entire item to validate
Convert takes: 0: single element to convert, if list (e.g., players)
			   1: should I also display the error text?
Display takes: %0 - list of elements to display
Filter is: How do I filter() for this? - 0: value, 2: comparison type (optional)


--------------------------------------------------------------------------------
-- Element: Name ---------------------------------------------------------------

The name of the storage group.  Must exist, always.

--

&element.name.position bbb=name entry. 1

&element.name.validate bbb=
	case(0, 
		t(%0), #-1 Name cannot be empty, 
		lte(strlen(%0), 30), #-1 Name must be 30 characters or less, 
		1
	)

&element.name.display bbb=
	localize(
		[setq(t, name)]
		[setq(v, titlestr(%0))]
		[setq(e, u(f.element.validate, %qt, %0))]
		[if(t(%qe), 
			%qv, 
			[ansi(r, %qv)][if(t(%1), ansi(xh, %b%([rest(%qe)]%)))]
		)]
	)

&element.name.filter bbb=
	localize(
		[setq(t, name)]
		[setq(e, get(%!/element.%qt.position))]
		[filter(fil.matches, 
			lattr(v(d.database)/[elements(%qe, 2)]*), 
			, 
			, 
			[elements(%qe, 3)], 
			%0
		)]
	)


--------------------------------------------------------------------------------
-- Element: Expires ------------------------------------------------------------

When does this element expire?

--

&element.expires.position bbb=expires entry. 2

&element.expires.validate bbb=
	case(0, 
		comp(%0, ), #-1 Expires cannot be empty, 
		isint(%0), #-1 Expires not in the expected format, 
		gt(%0, secs()), #-1 Expires has passed, 
		1
	)

&element.expires.convert bbb=
	switch(%0, 
		@@(null), @@(is null), 
		now, secs(), 
		da*, add(secs(), 86400), 
		wee*, add(secs(), 604800), 
		mon*, add(secs(), 2419200), 
		qua*, add(secs(), 7689600), 
		sem*, add(secs(), 15811200), 
		yea*, add(secs(), 31622400), 
		fiv*, add(secs(), 158112000), 
		convtime([mid(%0, 0, 4)]-[mid(%0, 4, 2)]-[mid(%0, 6, 2)] 	[extract(time(), 4, 1)])
	)

&element.expires.display bbb=
localize(
	[setq(t, expires)]
	[setq(v, if(isint(%0), timefmt($Y-$m-$d, %0), %0))]
	[setq(e, u(f.element.validate, %qt, %0))]
	[if(t(%qe), 
		%qv, 
		[ansi(r, %qv)][if(t(%1), ansi(xh, %b%([rest(%qe)]%)))]
	)]
)

&element.filter.date bbb=
	localize(
		[setq(t, date)]
		[setq(e, get(%!/element.%qt.position))]
		[setq(k, 
			case(%2, 
				>, is_more, 
				<, is_less, 
				=, is, 
				switch(%2, gr*, is_more, mo*, is_more, le*, is_less, is)
			)
		)]
		[filter(fil.%qk, 
			lattr(v(d.database)/[elements(%qe, 2)]*), 
			, 
			, 
			[elements(%qe, 3)], 
			%0
		)]
	)


--------------------------------------------------------------------------------
-- Element: Players ------------------------------------------------------------

A list of players associated with the element

--

&element.players.position bbb=players entry. 3

&element.players.validate bbb=
	if(not(t(%0)), 
		#-1 Players list cannot be empty, 
		iter(%0, 
			case(0, 
				t(pmatch(%i0)), #-1 Player not found, 
				comp(u(_isapproved, %i0), 0), #-1 Player not approved, 
				comp(u(_isapproved, %i0), -1), #-1 Player is frozen, 
				1
			)
			, , |
		)
	)

&element.players.convert bbb=iter(%0, pmatch(%i0))

&element.players.display bbb=
	localize(
		[setq(t, players)]
		[setq(e, u(f.element.validate, %qt, %0))]
		[setq(v, titlestr(%0))]
		[if(strmatch(%qe, *#-*), 
			%qv, 
			[ansi(r, %qv)][if(t(%1), ansi(xh, %b%([rest(%qe)]%)))]
		)]
	)

&element.players.filter bbb=
	localize(
		[setq(t, players)]
		[setq(e, get(%!/element.%qt.position))]
		[filter(fil.is, 
			lattr(v(d.database)/[elements(%qe, 2)]*), 
			, 
			, 
			[elements(%qe, 3)], 
			%0
		)]
	)


--------------------------------------------------------------------------------
-- Element: Text ---------------------------------------------------------------

The filler note-text.

--

&element.text.position bbb=text text. 1

&element.text.validate bbb=1[@@(always valid, may be null)]

&element.text.filter bbb=
	localize(
		[setq(t, text)]
		[setq(e, get(%!/element.%qt.position))]
		[filter(fil.matches, 
			lattr(v(d.database)/[elements(%qe, 2)]*), 
			, 
			, 
			[elements(%qe, 3)], 
			%0
		)]
	)


--------------------------------------------------------------------------------
-- Element: Others -------------------------------------------------------------

More of the same.

--

&element.bath.position bbb=bath entry. 4
&element.bath.validate bbb=case(0, t(%0), #-1 Bath cannot be empty, 1)

&element.blood.position bbb=blood entry. 5
&element.blood.validate bbb=case(0, t(%0), #-1 Blood cannot be empty, 1)

&element.frequency.position bbb=frequency entry. 6
&element.frequency.validate bbb=case(0, t(%0), #-1 Frequency cannot be empty, 1)

&element.effects.position bbb=frequency entry. 7
&element.effects.validate bbb=case(0, t(%0), #-1 Effects cannot be empty, 1)

&element.preparation.position bbb=frequency entry. 8
&element.preparation.validate bbb=case(0, t(%0), #-1 Preparation cannot be empty, 1)


================================================================================
== FUNCTIONS ===================================================================

--------------------------------------------------------------------------------
-- Function: Elements' Position List -------------------------------------------

0: list|of|elements
returns: The entire data segments from that list, |-delimited, partial-matches

--

&f.list.elements.position bbb=
	iter(
		lattr(%!/element.[edit(%0, %b, _)]*.position), 
		v(%i0), 
		, |
	)

--

think u(bbb/f.list.elements.position, *)
think u(bbb/f.list.elements.position, b)


--------------------------------------------------------------------------------
-- Function: Validate Element --------------------------------------------------

0: Element to validate (name completed already?)
1: Item(s) to validate
m: message returned from validation
returns: list|of|validations, where appropriate

--

&f.element.validate bbb=
localize(
	case(1, 
		strmatch(%1, *|*), #-1 [capstr(lcstr(%0))] may not contain pipe character, 
		strmatch(setr(m, udefault(element.%0.validate, 1, %1)), *#-*), 
		%qm, 1
	)
)

--

think u(bbb/f.element.validate, name, this|isatest)
think u(bbb/f.element.validate, name, )

think u(bbb/f.element.validate, expires, 123)
think u(bbb/f.element.validate, expires, abc)

think u(bbb/f.element.validate, players, #1 #999)

think u(bbb/f.element.validate, text, )


--------------------------------------------------------------------------------
-- Function: Convert Element ---------------------------------------------------

0: element name (validated)
1: data to convert
returns: conversion process, or %1 if not found

Simple.

--

&f.element.convert bbb=udefault(element.%0.convert, %1, %1)

--

think u(bbb/f.element.convert, name, This is a name)

think u(bbb/f.element.convert, expires, quarter)

think u(bbb/f.element.convert, players, thenomain troy)


--------------------------------------------------------------------------------
-- Function: Display Element ---------------------------------------------------

0: element name (validated)
1: data to display
2: 'true' if details about the error are desired
returns: Processed & errored data, else 

--

&f.element.display bbb=udefault(element.%0.display, %1, %1, %2)

--

think u(bbb/f.element.display, name, this|isatest)
think u(bbb/f.element.display, name, this|isatest, 1)
think u(bbb/f.element.display, name, , 1)

think u(bbb/f.element.display, expires, 1234567)
think u(bbb/f.element.display, expires, abc, 1)

think u(bbb/f.element.display, players, #1 #999 #188)
think u(bbb/f.element.display, players, #1 #999 #188, 1)

think u(bbb/f.element.display, text, @@(it's null), 1)
















================================================================================
== Mistress Commands ===========================================================

The "Mistress" Command structure (from Seth, AetherMux) allows a generic sorting system for easy refactoring.

It is entirely function-based.  Use trigger() when necessary.


--------------------------------------------------------------------------------
-- Mistress: Primary Command ---------------------------------------------------

1: /switches
2: text


&c.baths bbb=$^\+bath[s]?(/[^ ]*)?( .*)?$:
	@pemit %#=
		switch(1, 
			t(strlen(%1)), 
			u(c.baths.switch, %1, trim(%2)), 
			
			t(strlen(trim(%2))), 
			u(c.baths.specific, trim(%2), @@(pseudo-switches)), 
			
			u(c.baths.default)
		)

--

@set bbb/c.baths=regexp


--------------------------------------------------------------------------------
-- Mistress: Switches ----------------------------------------------------------

0: /switch/es
1: text (if passed)

n: command name ('poses')
s: switches found (c.baths/*)
p: pseudo-switches (others)

--

&c.baths.switch bbb=
	[setq(n, baths)]
	[setq(s, )]
	[setq(p, )]
	[setq(a, lattr(%!/c.%qn/*))]

@@ filter real (%qs) and psudo-switches (%qp)
	[iter(
		rest(%0, /), 
		if(
			t(grab(%qa, c.%qn/%i0*)), 
			setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), 
			setq(p, %qp/%i0)
		), 
		/, 
		@@
	)]

@@ process: 
	[if(t(%qs), 

@@ .. pass to first real-switch passed
		ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), 

@@ .. else pass to '.specific' or '.default' with pseudo-switches
		if(
			t(%1), 
				ulocal(c.%qn.specific, %1, %qp), 
				ulocal(c.%qn.default, %qp)
		)
	)]


--------------------------------------------------------------------------------
-- Mistress: Default -----------------------------------------------------------

0: psudo-switches, if passed (error'd, for +poses)

--

&c.baths.default bbb=
if(strlen(%1), 
@@ error on psudo-switches
	u(_alert, What did you want to do with that switch?), 

@@ ok
	u(c.baths/view, %0)
)


--------------------------------------------------------------------------------
-- Mistress: Specific ----------------------------------------------------------

0: text (<loc>[=<last>]|<last>)
1: psudo-switches, if passed

--

&c.baths.specific bbb=u(c.baths/view, %0, %1)


================================================================================
== Switched Commands ===========================================================

For all these commands: 

0: text
1: psudo-switches, if any


--------------------------------------------------------------------------------
-- /view -----------------------------------------------------------------------

	+<cmd>/view [<entry num>]

Display one or all possible items.

--

0: entry num, if any

n: entry number
l: list of pledges visible to the player; sorted by num desc

--

&c.baths/view bbb=
	[if(strlen(%0), 
@@ >> display one entry
		[setq(n, %0)]
	
		[case(0, 
			and(isint(%qn), gt(%qn, 0)), 
			u(_alert, +bath, Lookup must be a positive number), 

			or(isstaff(%#), t(match(u(f.get-elements, %qn, players), %#))), 
			u(_alert, +bath, You may not review someone else's entry), 

			t(get([u(d.pledges)]/pledge.%qn)), 
			u(_alert, +bath, Entry not found), 

			u(display.pledge.full, %qn)
		)], 

@@ >> display all entries
		[setq(l, 
			sortby(sort.entries, 
				filter(fil.pledge.can-see, lattr(u(d.database)/entry.*), , , %#)
			)
		)]

		[u(_header, Blood Bath Rituals)]%r

		[if(t(words(%ql)), 
			iter(%ql, u(display.bath.line, rest(%i0, .)), , %r), 
			%b No baths to list.
		)]%r

		[u(_footer, if(t(words(%ql)), [words(%ql)] baths))]
	)]


================================================================================
== Display =====================================================================


--------------------------------------------------------------------------------
-- Display: Full ---------------------------------------------------------------


&display.bath.full bbb=
	[u(_header, Bath #%0)]%r

@@ >> section: core elements
	[setq(e, Name Players Expires)]
	[setq(p, ulocal(f.get-elements, %0, %qe))]

	[iter(%qe, 
		[setq(d, extract(%qp, inum(), 1, |))]
		[setq(v, ulocal(f.element.validate, %i0, %qd))]
		[setq(d, ulocal(f.element.display, %i0, %qd, true))]
		[if(strlen(%qd), setq(d, [ansi(h, %i0:)] %qd))]
		[if(t(strlen(%qd)), 
			[wrap(
				%qd, 
				sub(74, add(2, strlen(%i0))), 
				left, %b%b, , add(2, strlen(%i0)), , 74
			)]%r
		)], 
		, @@
	)]

@@ >> section: secondary elements (must have at least one for display purposes)
	[setq(e, Bath Blood Frequency Effects Preparation)]
	[setq(p, ulocal(f.get-elements, %0, %qe))]

	[u(_divider, 
		if(strlen(edit(%qp, |, )), 
			Other Benefits, 
			%xr( Err: No Benefits Entered )%xn
		)
	)]%r

	[iter(%qe, 
		[setq(d, extract(%qp, inum(), 1, |))]
		[setq(v, ulocal(f.element.validate, %i0, %qd))]
		[setq(d, ulocal(element.%i0.display, %qd, true))]
		[if(strlen(%qd), setq(d, [ansi(h, %i0:)] %qd))]
		[if(
			t(strlen(%qd)), 
			[wrap(
				%qd, 
				sub(74, add(2, strlen(%i0))), 
				left, %b%b, , add(2, strlen(%i0)), , 74
			)]%r
		)], , @@
	)]

@@ >> section: detailed text
	[setq(d, ulocal(f.get-elements, %0, text))]
	[setq(v, ulocal(f.element.validate, text, %qd))]
	
	[if(strlen(%qd), 
		[u(_divider, Text)]%r
		[wrap(%qd, 74, left, %b%b)]%r
	)]
	
	[u(_footer, +bath %0)]


--------------------------------------------------------------------------------
-- Display: One Line -----------------------------------------------------------

&display.bath.line ddd=


































-- Function: Set Element --------------------


&F.SET-ELEMENT bbb=localize(
	[setq(e, u(f.data-elements.list, %1))]
	[setq(a, [extract(%qe, 2, 1)]%0)]
	[case(0, 
		comp(%qe, ), #-1 Element Requested Unknown, 

		eq(words(%qe, |), 1), #-1 Multiple Elements Found, 

		hasattr(u(d.database), [v(d.prefix)].%0), 
		#-1 [capstr(v(d.prefix))] #%0 Not Found, 

		[setq(p, ulocal([u(d.database)]/%qa))]
		[setq(p, replace(%qp, last(%qe), %2, |))]
		[setq(p, set([u(d.database)], %qa:%qp))]
		[if(comp(%qp, ), #-1 Error setting bath attribute, Set: Bath #%0's [first(%qe)] to '%2')]
	)]
)


-- Function: Validate Element

&F.element.validate bbb=
localize(
	case(1, 
		strmatch(%1, *|*), #-1 [capstr(lcstr(%0))] may not contain pipe character, 

		strmatch(setr(m, udefault(f.element.validate.%0, 1, %1)), #-*), %qm, 1
	)
)





-----------

&F.COUNTER.FREE Blood Bather Baths <bbb>=localize(first(setdiff(lnum(1, inc(last(setr(n, u(f.counter.baths))))), %qn)))

-----------


* Bath
	None (+3)
	Any Tub (+3)
	Specific Material (-1 to -5)
	Unique Tub (-5)
	Symbols and Carvings (-1, -2)
	Attendants (-2, -3, -5)
	Any Hour (+2)
	Day or Night (+1)
	Sunlight/Moonlight (0)
	Moon Phase (-1)
	Seasonal (-1)
	Stars Are Right (-2, -3)
* Blood
* Frequency
	Strict Timeline

* Effects
* Preparation
* Text






-----------


&F.SET-ELEMENT Blood Bather Baths <bbb>=localize([setq(e, u(f.data-elements.list, %1))][setq(a, [extract(%qe, 2, 1)]%0)][case(0, comp(%qe, ), #-1 Element Requested Unknown, eq(words(%qe, |), 1), #-1 Multiple Elements Found, hasattr(u(d.database), bath.%0), #-1 Bath #%0 Not Found, [setq(p, ulocal([u(d.database)]/%qa))][setq(p, replace(%qp, last(%qe), %2, |))][setq(p, set([u(d.database)], %qa:%qp))][if(comp(%qp, ), #-1 Error setting bath attribute, Set: Bath #%0's [first(%qe)] to '%2')])])

-----------


-----------


-----------

-----------

-----------


-----------


-----------


-----------


-----------

&F.GET-ELEMENTS Blood Bather Baths <bbb>=[setq(e, u(f.data-elements.list, %1))][case(0, comp(%qe, ), #-1 Element(s) Requested Unknown, t(get([u(d.database)]/bath.%0)), #-1 Bath #%0 Not Found, iter(%qe, extract(u([u(d.database)]/[extract(%i0, 2, 1)]%0), last(%i0), 1, |), |, |))]

-----------

&FIL.CONTAINS Blood Bather Baths <bbb>=t(match(elements(get([u(d.database)]/%0), %1, |), %2))

-----------

&FIL.MATCHES Blood Bather Baths <bbb>=t(strmatch(elements(get([u(d.database)]/%0), %1, |), *%2*))

-----------

&FIL.IS Blood Bather Baths <bbb>=eq(comp(elements(get([u(d.database)]/%0), %1, |), %2), 0)

-----------

&FIL.IS_MORE Blood Bather Baths <bbb>=eq(comp(elements(get([u(d.database)]/%0), %1, |), %2), 1)

-----------

&FIL.IS_LESS Blood Bather Baths <bbb>=eq(comp(elements(get([u(d.database)]/%0), %1, |), %2), -1)

-----------

&F.FILTER Blood Bather Baths <bbb>=localize([setq(e, u(f.data-elements.list, %0))][setq(n, first(%qe))][setq(c, u(f.convert-element, %qn, %1))][setq(v, u(f.element.validate, %qn, %qc))][case(0, eq(words(%0), 1), #-1 Filter only one element, eq(words(%qe, |), 1), #-1 Element not found, t(%qe), #-1 Elements: [rest(%qe)], t(%qc), #-1 Convert: [rest(%qc)], or(strmatch(%qe, date*), t(%qv)), %qv, ulocal(f.filter-workhorse, %qn, %qe, %qc, %2))])

-----------

&F.FILTER-WORKHORSE Blood Bather Baths <bbb>=case(0, strlen(setr(f, udefault(f.filter.%0, #-1 No filter for %0, %1, %2, %3))), #-1 No results, %qf)

-----------

&fil.elements.can-see Blood Bather Baths <bbb>=or(isstaff(%1), strmatch(last(get([u(d.database)]/%0), |), %1))


-----------

-----------


-----------

-----------

&F.COUNTER.baths Blood Bather Baths <bbb>=sort(edit(lattr(u(d.database)/bath.*), bath., ))

-----------


-----------

-----------

* Bath
	None (+3)
	Any Tub (+3)
	Specific Material (-1 to -5)
	Unique Tub (-5)
	Symbols and Carvings (-1, -2)
	Attendants (-2, -3, -5)
	Any Hour (+2)
	Day or Night (+1)
	Sunlight/Moonlight (0)
	Moon Phase (-1)
	Seasonal (-1)
	Stars Are Right (-2, -3)
* Blood
* Frequency
	Strict Timeline

* Effects
* Preparation
* Text


-----------

&sort.entries bbb=comp(rpad(last(%0, .), 3, 0), rpad(last(%1, .), 3, 0))

-----------
-----------


-----------

&display.bath.FULL Blood Bather Baths <bbb>=[u(_header, Bath #%0)]%r[setq(e, Name Player Demon Rank Sacrifices Date)][setq(p, ulocal(f.get-elements, %0, %qe))][iter(%qe, [setq(d, extract(%qp, inum(), 1, |))][setq(v, ulocal(f.element.validate, %i0, %qd))][setq(d, ulocal(display.element, %i0, %qd, true))][if(strlen(%qd), setq(d, [ansi(h, %i0:)] %qd))][if(t(strlen(%qd)), [wrap(%qd, sub(74, add(2, strlen(%i0))), left, %b%b, , add(2, strlen(%i0)), , 74)]%r)], , @@)][setq(e, Trait Supernatural Service Artifact)][setq(p, ulocal(f.get-elements, %0, %qe))][setq(n, if(strlen(edit(%qp, |, )), Benefits, %xr( Err: No Benefits )%xn))][center(%b%qn%b, 79, %xr-%xn)]%r[iter(%qe, [setq(d, extract(%qp, inum(), 1, |))][setq(v, ulocal(f.element.validate, %i0, %qd))][setq(d, ulocal(display.element, %i0, %qd, true))][if(strlen(%qd), setq(d, [ansi(h, %i0:)] %qd))][if(t(strlen(%qd)), [wrap(%qd, sub(74, add(2, strlen(%i0))), left, %b%b, , add(2, strlen(%i0)), , 74)]%r)], , @@)][setq(d, ulocal(f.get-elements, %0, text))][setq(v, ulocal(f.element.validate, text, %qd))][if(strlen(%qd), [center(%bText%b, 79, %xr-%xn)]%r[wrap(%qd, 74, left, %b%b)]%r)][u(_footer, +bath %0)]

-----------

-----------

&display.bath.LINE Blood Bather Baths <bbb>=[setq(e, Name Demon Rank Player Date)][setq(p, ulocal(f.get-elements, %0, %qe))]%b[rjust(%0, 3)]) [setq(d, elements(%qp, 1, |))][setq(v, ulocal(f.element.validate, name, %qd))][setq(d, ulocal(display.element, name, %qd))][ljust(if(t(%qv), %qd, ansi(r, %qd)), 39)] - [setq(d, elements(%qp, 2, |))][setq(v, ulocal(f.element.validate, type, %qd))][setq(d, strtrunc(ulocal(display.element, type, %qd), 4))][rjust(if(t(%qv), %qd, ansi(r, %qd)), 4)]/[setq(d, elements(%qp, 3, |))][setq(v, ulocal(f.element.validate, type, %qd))][setq(d, ulocal(display.element, type, %qd))][ljust(if(t(%qv), %qd, ansi(r, %qd)), 1)] - [setq(d, elements(%qp, 4, |))][setq(v, ulocal(f.element.validate, player, %qd))][setq(d, name(%qd))][ljust(if(t(%qv), %qd, ansi(r, %qd)), [setq(d, elements(%qp, 5, |))][setq(v, ulocal(f.element.validate, date, %qd))][if(t(%qv), 21, 12)])] [setq(d, ulocal(display.element, date, %qd))][if(t(%qv), , ansi(r, (expired)))]

-----------

&display.bath.PROVE Blood Bather Baths <bbb>=[setq(p, ulocal(f.get-elements, %0, edit(%1, |, %b)))][u(_header, Bath #%0 (from %N))]%r[iter(%1, [setq(d, extract(%qp, inum(), 1, |))][setq(v, ulocal(f.element.validate, %i0, %qd))][setq(d, [ansi(h, [titlestr(%i0)]:)] [ulocal(display.element, %i0, %qd, true)])][wrap(%qd, sub(74, add(2, strlen(%i0))), left, %b%b, , add(2, strlen(%i0)), , 74)], |, %r)]%r[u(_footer, +bath/prove %0)]

-----------


-----------

&C.BATH Blood Bather Baths <bbb>=$+bath*:@pemit %#=[setq(0, %0)][switch(%0, , u(c.bath.default), s, u(c.bath.default), s/*, u(c.bath.switch, /[first(after(%0, /))], rest(%0)), s%b*, u(c.bath.specific, trim(rest(%0))), /*, u(c.bath.switch, first(%0), rest(%0)), %b*, u(c.bath.specific, trim(%0)), Error: I don't know what you mean. Please see [ansi(h, +help bath)])]

-----------

&C.bath.SWITCH Blood Bather Baths <bbb>=udefault(first(sort(lattr(%!/c.*%0*))), [alert(bath)] No such switch., %1)

-----------

&C.bath.DEFAULT Blood Bather Baths <bbb>=[setq(l, sortby(sort.entries, filter(fil.elements.can-see, lattr([u(d.database)]/bath.*), , , %#)))][u(_header, baths)]%r[if(t(words(%ql)), iter(%ql, u(display.bath.line, rest(%i0, .)), , %r), %b No baths to list.)]%r[u(_footer, if(t(words(%ql)), [words(%ql)] baths))]

-----------

&C.bath.SPECIFIC Blood Bather Baths <bbb>=[setq(n, %0)][case(0, and(isint(%qn), gt(%qn, 0)), [alert(+bath)] Bath lookup must be a positive number., t(get([u(d.database)]/bath.%qn)), [alert(+bath)] Bath not found., or(isstaff(%#), t(match(u(f.get-elements, %qn, players), %#))), [alert(+bath)] You may not review someone else's bath., u(display.bath.full, %qn))]

-----------

&C.BATH/EDIT Blood Bather Baths <bbb>=[setq(n, first(%0, /))][setq(e, rest(first(%0, =), /))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, t(%qe), [alert(bath)] Element not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, eq(words(%qe), 1), [alert(bath)] Enter only one element, comp(setr(e, u(f.data-elements.list, %qe)), ), [alert(bath/edit)] Element not found, u(f.bath/edit.workhorse, %qn, first(%qe), %qv))]

-----------

&F.BATH/EDIT.WORKHORSE Blood Bather Baths <bbb>=[setq(p, ulocal(f.get-elements, %0, %1))][setq(c, ulocal(f.convert-element, %1, %2))][setq(v, ulocal(f.element.validate, %1, %qc))][setq(e, case(%1, player, if(land([iter(demon rank, [t(setr(z, ulocal(f.get-elements, %0, %i0)))] [t(ulocal(f.element.validate, %i0, %qz))])]), 1, #-1 Can't edit player until demon and rank are set and valid), 1))][case(0, t(%qv), [alert(bath)] [rest(%qv)], t(%qe), [alert(bath)] [rest(%qe)], u(f.bath/edit.process, %0, %1, %qp, %qc))]

-----------

&F.BATH/EDIT.PROCESS Blood Bather Baths <bbb>=[alert(bath)] Changing [ucstr(%1)] from '[u(display.element, %1, %2)]' to '[u(display.element, %1, %3)]' ... [setq(e, ulocal(f.set-element, %0, %1, %3))][if(t(%qe), set!, error: [rest(%qe)])]

-----------

&C.BATH/NEW Blood Bather Baths <bbb>=[setq(n, %0)][setq(c, u(f.counter.free))][case(0, isstaff(%#), [alert(bath)] Staff only, t(setr(e, u(f.element.validate, name, %qn))), [alert(bath)] [rest(%qe)], [set([u(d.database)], bath.%qc:%qn[repeat(|,dec(words(graball(u(d.elements.positions), * bath. *, |, |), |)))])][set([u(d.database)], benefits.%qc:[repeat(|,dec(words(graball(u(d.elements.positions), * benefits. *, |, |), |)))])][alert(bath)] Set up new bath [ansi(h, #%qc)] with name '[titlestr(%qn)]'.)]

-----------

&C.BATH/DELETE Blood Bather Baths <bbb>=[setq(n, before(%0, =))][setq(v, rest(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, eq(attrcnt([u(d.database)]/bath.%qn), 1), [alert(bath)] Bath not found, not(comp(%qv, YES)), [alert(bath)] If you are absolutely sure you want to delete this bath%, type: +bath/delete %qn=YES, [u(_header, Deleting Bath #%qn)]%r[ulocal(display.bath.full, %qn)]%r[setq(p, set([u(d.database)], bath.%qn:))][setq(b, set([u(d.database)], benedits.%qn:))][setq(t, set([u(d.database)], text.%qn:))][u(_footer, case(1, comp(%qp, ), Error Clearing &Bath: %qp, comp(%qb, ), Error Clearing &Benefits: %qb, comp(%qt, ), Error Clearing &Text: %qt, Deleted))])]

-----------

&C.BATH/PROVE Blood Bather Baths <bbb>=[setq(n, first(before(%0, =), /))][setq(e, if(setr(e, before(rest(%0, /), =)), %qe, Name Demon Rank Sacrifices Date Player Trait Supernatural Service Artifact Text))][setq(l, crumple(iter(ulocal(f.data-elements.list, %qe), first(%i0), |, |), |))][setq(p, rest(%0, =))][setq(d, iter(%qp, if(t(setr(d, pmatch+(%i0))), %qd)))][case(0, and(isint(%qn), gt(%qn, 0)), [alert(+bath)] Bath lookup must be a positive number., t(get([u(d.database)]/bath.%qn)), [alert(+bath)] Bath not found., or(isstaff(%#), t(match(u(f.get-elements, %qn, players), %#))), [alert(+bath)] You have no access to that bath., or(not(%qp), t(%qd)), [alert(+bath)] No target players matched., words(%ql), [alert(+bath)] Element(s) not found., pemit(if(t(%qd), setunion(%# %qd, ), lcon(loc(%#), connect)), u(display.bath.prove, %qn, %ql)))]

-----------

&C.BATH/PLAYER Blood Bather Baths <bbb>=[setq(t, player)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/TEXT Blood Bather Baths <bbb>=[setq(t, text)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/NAME Blood Bather Baths <bbb>=[setq(t, name)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/DEMON Blood Bather Baths <bbb>=[setq(t, demon)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/RANK Blood Bather Baths <bbb>=[setq(t, rank)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/DATE Blood Bather Baths <bbb>=[setq(t, date)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/TRAIT Blood Bather Baths <bbb>=[setq(t, trait)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/SUPERNATURAL Blood Bather Baths <bbb>=[setq(t, supernatural)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/DURATION Blood Bather Baths <bbb>=[u(c.bath/date, %0)]

-----------

&C.BATH/SERVICE Blood Bather Baths <bbb>=[setq(t, service)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/ARTIFACT Blood Bather Baths <bbb>=[setq(t, artifact)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

&C.BATH/RAW Blood Bather Baths <bbb>=[setq(n, first(%0, /))][setq(e, rest(%0, /))][setq(p, ulocal(f.get-elements, %qn, %qe))][case(0, isstaff(%#), [alert(bath)] Staff only., t(%qn), [alert(bath)] Number not entered, t(%qe), [alert(bath)] Element not entered, eq(words(%qe)), [alert(bath)] One element only, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, comp(setr(e, first(u(f.data-elements.list, %qe))), ), [alert(bath)] Element not found, [alert(bath #%qn)] [ansi(h, titlestr(%qe))]: %qp)]

-----------

&C.BATH/FILTER Blood Bather Baths <bbb>=[setq(m, regmatch(%0, (.*)(\[<>=\])(.*), m e c v))][setq(e, trim(%qe))][setq(v, trim(%qv))][setq(f, u(f.filter, %qe, %qv, %qc))][case(0, t(%qm), [alert(bath)] Filter format: <element> <comparison> <value>, t(%qf), [alert(bath)] [rest(%qf)], [setq(f, iter(%qf, bath.[last(%i0, .)]))][setq(l, sortby(sort.entries, filter(fil.elements.can-see, %qf, , , %#)))][u(_header, baths: Filtered by '%qv')]%r[if(t(words(%ql)), iter(%ql, u(display.bath.line, rest(%i0, .)), , %r), %b No baths to list.)]%r[u(_footer, if(t(words(%ql)), [words(%ql)] baths))])]

-----------

-----------

-----------


-----------


-----------

&C.BATH/SACRIFICES Blood Bather Baths <bbb>=[setq(t, sacrifices)][setq(n, first(%0, =))][setq(v, last(%0, =))][case(0, isstaff(%#), [alert(bath)] Staff only, t(%qn), [alert(bath)] Number not entered, attrcnt([u(d.database)]/bath.%qn), [alert(bath)] Bath not found, [u(f.bath/edit.workhorse, %qn, %qt, %qv)])]

-----------

