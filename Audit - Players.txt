=========================> @whence command matches <============================
   #653 Random Global Storage  (Is) ......... do_freezer ......... +freeze *
=================================================================> 1 match <====
DO_FREEZER [#3087]: $+freeze *:[setq(0, pmatch++(%0))]; @swi/first 0=isstaff(%#), {@pemit %#=Huh? (Type "help" for help.)}, isdbref(%q0), {@pemit %#=[ansi(hx, ERROR)]: '[secure(%0)]' does not seem to be the name of a player.}, not(match(loc(%q0), #1408)), {@pemit %#=[ansi(hx, GAME)]: [name(%q0)] is already in the Freezer.}, {&freezer_loc %q0 = [loc(%q0)]; @lock %q0/freezer_loc; @tel %q0=#1408; &freezer_home %q0 = [home(%q0)]; @lock %q0/freezer_home; @link %q0=#1408; @pemit %#=[ansi(hx, GAME)]: You sent [name(%q0)] to the Freezer.; @name %q0=[name(%q0)]_[rest(%q0, #)]; @pemit %q0=[ansi(hx, GAME)]: %N has sent you to the Freezer and renamed you to [name(%q0)].; @set %q0=!APPROVED FIXED; think [u(#3088/FCT.XP.UPDATE, %#, %q0, 0, Character Frozen)]}

--

&DO_FREEZER #653=$+freeze *:

think setq(0, pmatch++(%0)); 

@swi/first 0=
	isstaff(%#), 
	{ @pemit %#=Huh? (Type "help" for help.) }, 

	isdbref(%q0), 
	{ @pemit %#=[ansi(hx, ERROR)]: '[secure(%0)]' does not seem to be the name of a player. }, 

	not(match(loc(%q0), #1408)), 
	{ @pemit %#=[ansi(hx, GAME)]: [name(%q0)] is already in the Freezer. }, 

@@ .. else
	{ 
		&freezer_loc %q0 = [loc(%q0)]; 

		@lock %q0/freezer_loc; 

		@tel %q0=#1408; 

		&freezer_home %q0 = [home(%q0)]; 

		@lock %q0/freezer_home; 

		@link %q0=#1408; 

		@pemit %#=[ansi(hx, GAME)]: You sent [name(%q0)] to the Freezer.; 

		@name %q0=[name(%q0)]_[rest(%q0, #)]; 

		@pemit %q0=[ansi(hx, GAME)]: %N has sent you to the Freezer and renamed you to [name(%q0)].; 

		@set %q0=!APPROVED FIXED; 

		think u(#3088/FCT.XP.UPDATE, %#, %q0, 0, Character Frozen) 
	}

--

F_PMATCH++ [#3087]: localize(if(setr(p, pmatch(%0)), %qp, first(search(eplayer=strmatch(name(##), %0*)))))


--

c.freezer
trig.freezer.staff
trig.freezer.frozen
trig.freezer.permafrozen
trig.freezer.create-job

--

ex #978/fp*isapproved
&FP_ISAPPROVED #978=or(isstaff(%0),hasflag(%0,approved))


################################################################################
## FREEZER MANAGEMENT CODE #####################################################

Yeah, it's complex enough that it gets its own object.


================================================================================
== CREATE: Freezer Management Object ===========================================

@create Freezer Management Object <fmo>=10

@set fmo=safe inherit

@parent fmo=#2833
&prefix.cross-platform_functions fmo=.
&prefix.reports fmo=report.


================================================================================
== CROSS-PLATFORM FUNCTIONS ====================================================

&.isstaff fmo=isstaff( %0 )
&.pmatch+ fmo=pmatch++( %0 )

&.superheader fmo=edit( u( .header, %0 ), =, #, >, %[, <, %] )
&.superfooter fmo=edit( u( .footer, %0 ), =, #, >, %[, <, %] )
&.header fmo=header( %0 )
&.footer fmo=footer( %0 )
&.divider fmo=divider( %0 )
&.notice fmo=ansi( h, <freeze> )
&.titlestr fmo=titlestr( %0, %1 )

&.places fmo=places( %0, %1, %2 )


--

@@ Uses TinyMUX columns() - redefine for your platform of choice

&.columns fmo=columns(%0, %1, %2, %3)

--

@@ some people have andlist()

&.itemize fmo=itemize( %0, %1, %2, %3 )



================================================================================
== DATA ========================================================================

&d.freezer.player fmo=#1408
&d.freezer.staff fmo=#803

&d.ajobs.job-tracker fmo=#2594
&d.ajobs.report-jgroup fmo=+Build
&d.ajobs.report-bucket fmo=BUILD

&d.notes.object fmo=#116

&d.important-flags fmo=WIZARD ROYALTY STAFF IMMORTAL GAGGED GUEST PRPRUNNER NPC  OPEN_OK PARENT_OK ABODE ROBOT SLAVE

&d.important-flags.hidden fmo=SITEMON SUSPECT



================================================================================
== USER FUNCTION: isapproved() =================================================

	isapproved(<dbref>[, <approval type>])

This is the updated isapproved() function. Priv'd Function.

FLAGS:
	approved, frozen, exstaff, permafrozen

APPROVAL TYPES:
	approved: has the approval flag (default)
	frozen: has the frozen or exstaff flag
	exstaff, ex-staff, staff: has the exstaff flag
	permafrozen: has the permafrozen flag
	unapproved, never: none of the above

--

0: <dbref>
1: <approval type>

--

&ufunc.isapproved fmo=
	switch( %1, 
		a*, cor( isstaff( %0 ), hasflag( %0, approved )), 
		f*, hasflag( %0, frozen ), 
		ex*, hasflag( %0, exstaff ), 
		st*, hasflag( %0, exstaff ), 
		p*, hasflag( %0, permafrozen ), 
		un*, not(cor( u( .isstaff, %0 ), orflags( %0, 0167 ))), 
		nev*, not(cor( u( .isstaff, %0 ), orflags( %0, 0167 ))), 
		cor( isstaff( %0 ), hasflag( %0, approved ))
	)



================================================================================
== MISTRESS SYSTEM =============================================================

The usual cascading command to switches, unknown switches sent as "fake" switches, but will almost certainly be ignored.


--------------------------------------------------------------------------------
-- Mistress: Setup -------------------------------------------------------------

n: name of the command for finding right attr
   GLOBAL REGISTER - holds command/alias player is using

--

&c.freezer fmo=$+freeze*:@pemit %#=
	[setq(n, freezer)]
	[switch(%0, 

@@ Without 'r' ending
		, u(c.%qn.default), 
		/*, u(c.%qn.switch, first(%0), rest(%0)), 
		%b*, u(c.%qn.specific, trim(%0)), 

@@ With 'r' ending
		r, u(c.%qn.default), 
		r/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), 
		r%b*, u(c.%qn.specific, trim(rest(%0))), 

@@ No match
		Error: I don't know what you mean. Please see [ansi(h, +help %qn)]
	)]


--------------------------------------------------------------------------------
-- freezer/<switch> ------------------------------------------------------------

Handles all /switches, which is to say it makes sure they exist and passes them on.

Also handles pseudo-switches, passing them on as elements to any switched item.

Passes to &c.<name>.specific (%1, %qp) or &c.<name>/<switch> (%1, %qp), even if %1 is empty.

--

0: /<switch>[/<switch>/<switch>, etc.]
1: [<more>], stuff to pass to c.<name>/<switch>, if any

n: Name of the command, global register set in &c.<name> (set above)
   'qn' MUST BE MAINTINED after this command (for aliases)

a: all c.<name>/* on this object
s: /valid/command/switches/found
p: /pseudo/switches/found, pass to c.<name>[/<switch>]

--

&c.freezer.switch fmo=
	[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))]
	[iter(rest(%0, /), 
		if(
			t(grab(%qa, c.%qn/%i0*)), 
			setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), 
			setq(p, %qp/%i0)
		), 
		/, @@
	)]
	[if(t(%qs), 
		ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), 
		if(t(%1), 
			ulocal(c.%qn.specific, %1, %qp), 
			ulocal(c.%qn.default, %1, %qp)
		)
	)]


--------------------------------------------------------------------------------
-- freezer (default) -----------------------------------------------------------

Nothing for now.

n: name of calling command/alias, MUST BE MAINTAINED after this command

--

0: ignored
1: fake /switches, if any

l: location of %#

--

&c.freezer.default fmo=[u(.notice)] No default available.


--------------------------------------------------------------------------------
-- freezer <stuff> (specific) --------------------------------------------------

Freeze this person

--

0: player to freeze
1: fake /switches

t: target

--

&c.freezer.specific fmo=
	[setq( t, u( .pmatch+, trim( secure( %0 ))))]

	[case( 0, 
		isstaff(%#), 
		[u(.notice)] Staff only, 

		t(hastype( %qt, PLAYER )), 
		[u(.notice)] Cannot find '[trim( secure( %0 ))]', 

		not( u( ufunc.isapproved, %qt, permafrozen )), 
		[u(.notice)] '[name( %qt )]' is already permafrozen, 

		not( u( ufunc.isapproved, %qt, exstaff )), 
		[u(.notice)] '[name( %qt )]' is already exstaff, 

		not( u( ufunc.isapproved, %qt, frozen )), 
		[u(.notice)] '[name( %qt )]' is already frozen, 

		not( u( ufunc.isapproved, %qt, unapproved )), 
		[u(.notice)] '[name( %qt )]' (%qt) has never been approved and should be destroyed instead, 

@@ OK GO
		trigger(%!/trig.freeze, 
			%#, 
			%qt, 
			if( u( .isstaff, %qt ), staff, player )
		)
	)]


================================================================================
== SWITCH: /permafreeze ========================================================

&c.freezer/permafreeze fmo=I Am /Permafreeze


================================================================================
== SWITCH: /list ===============================================================

(???)
	+freezer/list [<approval type>]

--

&c.freezer/list fmo=I Am /List


================================================================================
== TRIGGER: Freeze Person ======================================================

0: trigerer
1: person to freeze
2: 'player' or 'staff'

n: name of staffer

--

&trig.freeze fmo=
	think >> trig.freeze (%2) >> target name: [setr(n, name( %1 ))]; 

	@pemit %0=[u(.notice)] Trying to %2-freeze %qn (%1); 

@@ remove all powers
	@power %0=[iter( powers( %1 ), !%i0) ]; 

@@ remove all staff-related flags
	@set %0=!staff !royalty !dark !inherit; 

@@ move to correct freezer
	@tel/quiet %1=[v( d.freezer.%2 )]; 
	@link %1=[v( d.freezer.%2 )]; 

@@ remove from +jgroups (Anomaly Jobs)
	@trigger %!/ajobs.trig.remove-from-jgroups=%1, %qn; 

@@ >> staffer
	@if strmatch( %2, staff )=
		{ 

@@ .. remove from 'staff' channel
			@cboot %1=Staff; 

@@ .. remove from staff rosters (different on every game)
			@trigger %!/trig.staff-roster.remove=%1; 

@@ .. >> MUST BE DONE BY HAND: 
@@ .. .. Remove Wiz Flag (if exists)
			@if hasflag(%1, WIZARD)=
				{ @pemit %0=[u(.notice)] Remember to remove the Wizard flag from '%qn' }; 

@@ .. .. Remove Wiki & Forum privs
			{ @pemit %0=[u(.notice)] Remember to remove privs from '%qn' on the Wiki and Forums }
		 }; 

@@ >> OK, MAKE THE JOB
	@trigger %!/trig.create-freeze-job=%0, %1, %2; 


================================================================================
== TRIGGER: Remove from Staff Rosters ==========================================

The Reach: +staff/del name=dept to remove them from the #99 +staff lists

--

&trig.staff-roster.remove fmo=
	@dolist grepi( #99, v_dept_*, %0 )=
		{ +staff/del [name( %0 )]=[last(##, _)] }; 


================================================================================
== ANOMALY JOBS ================================================================

Interfaces for Anomaly Jobs

--------------------------------------------------------------------------------
-- SETUP: ajobs for codp -------------------------------------------------------

&prefix.anomaly_jobs fmo=ajobs.


--------------------------------------------------------------------------------
-- TRIGGER: remove from jgroups ------------------------------------------------

&ajobs.trig.remove-from-jgroups fmo=
	@dolist u( ajobs.f.belongs-to-jgroups, %0 )=
		{ +jgroup/member %1=[name( ## )] }; 


--------------------------------------------------------------------------------
-- FUNCTION: belongs to jgroups ------------------------------------------------

0: player dbref

--

&ajobs.f.belongs-to-jgroups fmo=
	filter( ajobs.filter.belongs-to-jgroup, 
		lcon( v( d.ajobs.job-tracker )), , , %0 
	)


--------------------------------------------------------------------------------
-- FILTER: belongs to +jgroup --------------------------------------------------

0: +jgroup object dbref
1: player dbref

--

&ajobs.filter.belongs-to-jgroup fmo=t( match( get( %0/memberlist ), %1 ))



================================================================================
== TRIGGER: Create Freezer Job =================================================

This is a personal game-by-game feature.


--------------------------------------------------------------------------------
-- Create Freeze Job -----------------------------------------------------------

1) Create job. Job is "opened by" frozen player, but an initial email is not sent.

Creation job text should include:
	- Name/Dbref
	- Frozen/Permafrozen/StaffFrozen

Initial job timeout is 30 days for frozen, 14 days for permafrozen/staff frozen, which should be time enough to allow the player to respond.

2) job/mail each additional report to it.
	- Player Report
	- Objects Report
	- Rooms & Other Exits Report

3) job/mail final information: Additional information entered by staffer & "Tell us what you want to do with this."


Player dbref must be validated by now.

--

0: dbref of enactor
1: dbref of target
2: 'player' or 'staff'

r: rooms list
e: exits list
o: objects list
p: players list (very rarely used, if ever)
n: visible notes list
i: invisible notes list (staffnotes)
f: factions
c: complete list of factions

x: output
v: very-temporary-holder

--

&trig.create-freeze-job fmo=

@@ COMPILE LISTS
	think 
		strcat( 
			>> trig.create-freeze-job >>%r, 
			>> dbref: %1%r, 
			>> rooms:%b, setr( r, search( %1 type=rooms )), %r, 
			>> exits:%b, setr( e, search( %1 type=exits )), %r, 
			>> objects:%b, setr( o, search( %1 type=objects )), %r, 
			>> players:%b, setr( p, search( %1 type=players )), %r, 
			>> notes:%b, setr( n, u( notes.list-notes-attrs, %1, player )), %r, 
			>> invisible notes:%b, setr( i, u( notes.list-notes-attrs, %1, staff )), 
			%r, 
			>> factions:%b, 
			setr( f, u( factions.list-factions, %1, player )), %r, 
			>> compl fac:%b, 
			setr( c, u( factions.list-factions, %1, staff )), %r, 
		); 

@@ OPEN JOB



@@ REPORT ...
	think 
		setr( x, 
			strcat(
				u( .header, Freeze for [capstr( %2 )]: [name( %1 )] (%1) ), 
				%r%r, 

@@ .. ROOMS
				if( t( %qr ), 
					strcat( %qx, 
						u( .header, Rooms (count: [words( %qr )]) ), %r,
						u( report.rooms, %qr ), %r
					)
				), 

@@ .. EXITS
				if( t( %qe ), 
					strcat( %qx, 
						u( .header, Other Exits (count: [words( %qe )]) ), %r,
						u( report.other-exits, %qr ), %r
					)
				), 


			)
		)


================================================================================
== FACTIONS ====================================================================

Interfaces with the Aether Factions System. If you use Amberyl's Org code, look here.

--

&prefix.factions fmo=factions.

&d.factions fmo=#2832


--------------------------------------------------------------------------------
-- FACTIONS: List Factions -----------------------------------------------------

	u( factions.list-factions, <player dbref>, 'staff' or 'player' )

%0: player dbref
%1: 'staff' or 'player' (default)

--

&factions.list-factions fmo=
@@ filter from 'staff' (all) or 'player' (some may not be visible)
filter(
	v( d.factions )/fil.see-faction, 
	setunion( 

@@ .. from player object
		iter( get( %0/_faction-member ), rest( %i0, ! ), | ), 

@@ .. from faction objects
		filter( factions.filter.player-in-faction, 
			lcon( v( d.factions ), object ), , , %1 
		)
	), , , 
@@ .. see faction list as '#1' if 'staff' is passed
	switch(%1, st*, #1, %0)
)


--------------------------------------------------------------------------------
-- FACTIONS: Filter, player in faction -----------------------------------------

	filter(factions.filter.player-in-faction, <factions>, , , <player> )

0: faction dbref
1: player dbref

--

&factions.filter.player-in-faction fmo=hasattr(%0, member-%1)


--------------------------------------------------------------------------------
-- FACTIONS: Filter, object is faction -----------------------------------------

Return things that are valid faction objects. We'll probably need this. We might not.

0: faction dbref

--

&faction.filter.object-is-faction fmo=strmatch( loc( %0 ), v( d.factions ))


--------------------------------------------------------------------------------
-- FACTIONS: Get Faction Name --------------------------------------------------

&factions.name fmo=name( %0 )


================================================================================
== REPORTS =====================================================================

&prefix.reports fmo=report.


--------------------------------------------------------------------------------
-- REPORT: Initial -------------------------------------------------------------

The initial report has the general information for the freeze job. Because Anomaly Jobs doesn't seem to email the person who submitted the job (via TRIG_CREATE, at least), this is a boilerplate header.

0: target dbref
1: freeze, permafreeze, stafffreese

--

&report.initial fmo=
	[u( .superheader, 
		[ucstr( %1 )] for 
		[if( u( .isstaff, %0 ), STAFF, PLAYER )]: [name( %0 )] (%0) 
	)]%r
	The player object [name( %0 )] (%0) is being [edit(lcstr( %1 ), freeze, frozen )] at [time()]. What follows are reports on items related to the player object.


--------------------------------------------------------------------------------
-- REPORT: Final ---------------------------------------------------------------

After all the above reports are added to the job, a final summary report is filed which thanks the player and adds additional comments from the staffer doing the freezing.

--

0: target dbref
1: enactor dbref
2: final message (if any)

--

&report.final fmo=
	[u( .superheader, 
		Final Words
	)]%r%r

	[if( t( strlen( %2 )), u( .divider, Notes from [name( %1 )] )%r%2%r[u( .divider )]%r%r)]

	If you have any questions, parting comments, or if you'd like to see something specific done with anything listed above, let staff know through this job and we'll do our best to accommodate you.%r%r

	Thank you for all your time. - The Reach Staff

--------------------------------------------------------------------------------
-- REPORT: Player --------------------------------------------------------------

Reports:
	- Player name/dbref
	- If staff
	- Name of notes (views/staffnotes) visible to player
	- Number of notes (etc.) not visible to player
	- Items linked to player

--

0: player dbref
1: dbref to view as (optional, defaults to %0)

w: which is the target, player or staffer?
v: view-as dbref
s: which is the viewer, player or staffer?

--

&report.player fmo=
strcat(
	setq( w, if( u( .isstaff, %0 ), staffer, player )), 
	setq( v, if( isdbref( %1 ), %1, %0 )), 
	setq( x, if( u( .isstaff, %qv ), staffer, player )), 

	u( .superheader, [ucstr(%qw)]: [name( %0 )] (%0) ), 

@@ important flags & powers
	if( 
		t( setr( i, 
			setinter( 
				lflags( %0 ), 
@@ .. list 'hidden' flags if viewer is staff
				cat( 
					v( d.important-flags ), 
					if( strmatch( %qx, staffer ), v( d.important-flags.hidden ))
				)
			)
		)), 
		ansi(h, %rFlags:%b, n, lcstr( %qi ), n), 
		setq( i, )
	), 
	if( not( t( %qi )), %r ), 

	if( t( setr( i, powers( %0 ))), 
		ansi( h, %rPowers:%b, n, lcstr( %qi ), n, %r )
	), 

@@ Factions info (before removed)
	if( t( setr( f, ulocal( factions.list-factions, %0, %qx))), 
		ulocal( report.factions, %0, %qf, Factions ), 
	), 

@@ SASS info (pledges, pacts, etc.)
	if( t( setr( s, ulocal( sass.list-items, %0, %qx ))), 
		ulocal( report.sass, %0, %qs, Agreements ), 
	), 

@@ notes/views/etc
	u( report.notes, %0, %qx, Notes, header), 

@@ linkages
	ulocal( report.linkages, %0, Linkages, header ), 

	u( .superfooter )
)


--------------------------------------------------------------------------------
-- REPORT: Notes ---------------------------------------------------------------

Generic 'notes' report.

0: dbref concerning report (target)
1: viewer is 'player' or 'staffer'
2: title
3: header type, default 'header'

n: list of notes
i: various 'if' results

--

&report.notes fmo=
localize(
	strcat( 
		setq( n, u( notes.list-notes-attrs, %0, %1 )), 
		if( t( %qn ),  
			strcat( 
				u( .[if( t( %3 ), %3, header )], %2 ), %r, 
				u( .columns, 
					iter( %qn, u( notes.title, %0, %i0 ), , _ ), 
					37, _, 2 
				)
			)
		), 
		if( 
			cand(
				t( setr( i, ulocal( notes.list-notes-attrs, %0, staff ))), 
				not( strmatch( %1, staffer ))
			), 
			ansi( nh, 
				cat( 
					%rThere are, words( %qi ), 
					additional notes not visible to this, 
					lcstr( type( %0 )), bit.%r 
				)
			)
		)
	)
)
	


--------------------------------------------------------------------------------
-- REPORT: Factions ------------------------------------------------------------

Generic 'factions' report. Will try to report regardless if any exist

0: dbref concerning report (unused here, but better safe than sorry)
1: list of factions (dbrefs)
2: header

--

&report.factions fmo=
	strcat( 
		u( .header, %2 ), %r, 
		u( .columns, iter( %1, u( factions.name, %i0 ), , _ ), 37, _, 2 )
	)


--------------------------------------------------------------------------------
-- REPORT: S.A.S.S -------------------------------------------------------------

Reports the various supernatural agreements held by the player. Tries to report regardless if there's anything there

0: dbref of player (probably not needed, here just in case)
1: output from 'sass.list-items'
2: header

--

&report.sass fmo=
	strcat( 
		u( .header, %2 ), %r, 
		iter( %1, 
			strcat(
				u( .divider, first( %i0, : )), %r, 
				u( .columns, edit( rest( %i0, : ), :, %)%b ), 37, |, 2)
			), 
			||, %r 
		)
	)

--

think u(fmo/report.sass, pmatch(kelvin), u( fmo/sass.list-items, pmatch(kelvin), player ), AGREEMENTS)


--------------------------------------------------------------------------------
-- REPORT: Linkages ------------------------------------------------------------

Players, objects, and rooms can link places. It's important to know.

0: object dbref
1: title
2: header type (defaults divider)

i: temp information
r: temp report

--

&report.linkages fmo=
localize( 
	strcat( 
		setq(r, ), 

		if( t( setr( i, u( report.link.players, %0 ))), setq( r, %qr%b %qi )), 
		if( t( setr( i, u( report.link.objects, %0 ))), setq( r, %qr%b %qi )), 
		if( t( setr( i, u( report.link.rooms, %0 ))), setq( r, %qr%b %qi )), 

		if( t( %qr ), u( .[if( t( %2 ), %2, divider )], %1 )%r%qr )
	)
)

--------------------------------------------------------------------------------
-- REPORT: Rooms ---------------------------------------------------------------

0: list of rooms
1: target (player) dbref, expecting owner
2: viewer's dbref (optional)

i: 'if' condition looking for at the moment so it can be reported
x: viewer is 'staffer' or 'player' - viewer defaults to target

--

&report.rooms fmo=
localize(
	strcat( 
		setq( x, if( u( .isstaff, if( t( %2 ), %2, %1 )), staffer, player )), 
		u( .superheader, ROOMS ), %r, 

@@ for each room ...
		iter( %0, 
			strcat( 
				u( .header, ROOM #[inum(0)] ), %r, 

@@ .. basic data (name / dbref / &coord / &owner / places / linkages)
				ansi( h, %b Name:%b), name( %i0 ), %r, 
				ansi( h, %b Dbref:%b), %i0, %r, 

				u( .columns, 
					setunion( 
						if( t( setr( i, lcstr( get( %i0/coord )))), 
							ansi( h, &coord:%b, n, %qi )
						), 
						if( t( setr( i, get( %i0/owner ))), 
							ansi( h, &owner:%b, n, %qi )
							), 
						|
					), 
					37, |, 2
				), 

				if( t( setr( i, u( report.places, %i0 ))), %b %qi ), 
				ulocal( report.linkages, %i0, Linkages, none ), 

@@ .. notes/views/etc
				ulocal( report.notes, %i0, %qx, Notes, divider), 

@@ .. report on exits
				if( 
					t( setr( i, 
						filter( filter.owned-by-player, lexits( %i0 ), , , %1 )
					)), 
					[u( .divider, Exits )]%r
					[iter( %qi, u( report.room-exit, %i0, Exits ), , %r )]%r
				), 

@@ .. report on 'other exits' (exits not owned by target player)
				if( 
					t( setr( i, setdiff( lexits( %i0 ), %qi ))), 
					%b There are [words(%qi)] other exit(s) in this room. %r 
				), 

				u( .footer )
			), , %r 
		), %r, 
		u( .superfooter, [words(%0)] Rooms )
	)
)


--

think [u(fmo/report.rooms, setr(r, search(#3225 type=room)), #3225)]

think [setq(0, pmatch(gil))][u(fmo/report.rooms, setr(r, search(%q0 type=room)), %q0)]


--------------------------------------------------------------------------------
-- FUNCTION: Who Lives Here? ---------------------------------------------------

0: room
1: 'player', 'object', 'room', 'exit' (better served with lexits())

&f.search.who-lives-here fmo=search( e%1=strmatch( %0, home( ## )))

--

&f.search.it-is-here fmo=search( e%1=strmatch( %0, loc( ## )))


--------------------------------------------------------------------------------
-- FUNCTION: Link Report: Players ----------------------------------------------

&report.link.players fmo=
	if( 
		t(setr( i, u( f.search.who-lives-here, %0, player ))), 
		ansi( h, cat( words(%qi), people link here!%r ))
	)


--------------------------------------------------------------------------------
-- FUNCTION: Link Report: Objects ----------------------------------------------

&report.link.objects fmo=
	if( 
		t(setr( i, u( f.search.who-lives-here, %0, object ))), 
		ansi( h, cat( words(%qi), objects link here!%r ))
	)


--------------------------------------------------------------------------------
-- FUNCTION: Link Report: Rooms ------------------------------------------------

&report.link.rooms fmo=
	if( 
		t(setr( i, u( f.search.who-lives-here, %0, room ))), 
		ansi( h, cat( words(%qi), rooms dump here!%r ))
	)


--------------------------------------------------------------------------------
-- FUNCTION: Link Report: Exits ------------------------------------------------

&report.link.exits fmo=
		if( 
			t(setr( i, u( f.search.it-is-here, %0, exit ))), 
			ansi( h, cat( words(%qi), exits link here!%r ))
		)


--------------------------------------------------------------------------------
-- FUNCTION: Note Report: Views ------------------------------------------------

0: dbref, 1: object type

--

&report.note.views fmo=
	if( t( setr( i, u( notes.list-notes-attrs, %0, views ))), 
		cat( This %1 has, words( %qi ), view(s). %r )
	)


--------------------------------------------------------------------------------
-- FUNCTION: Note Report: Notes ------------------------------------------------

&report.note.notes fmo=
	if( t( setr( i, u( notes.list-notes-attrs, %i0, notes ))), 
		cat( This %1 has, words( %qi ), note(s). %r )
	)


--------------------------------------------------------------------------------
-- FUNCTION: Note Report: Staffnotes -------------------------------------------

&report.note.staffnotes fmo=
	if( t( setr( i, u( notes.list-notes-attrs, %i0, staffnotes ))), 
		cat( This %1 has, words( %qi ), staffnote(s). %r )
	)


--------------------------------------------------------------------------------
-- FUNCTION: Places Report -----------------------------------------------------

&report.places fmo=
	if( t( setr( i, u( .places, list, %i0 ))), 
		cat(This room has, words( %qi, | ), place(s) %r)
	)


--------------------------------------------------------------------------------
-- REPORT: Report Exits in Room owned by Player --------------------------------

0: exit dbref

i: temp information

--

&report.room-exit fmo=
localize( 
	strcat( 
@@ .. dark?
		setq( i, 
			if( hasflag( %0, dark ), 
				setunion(%qi, dark, |)
			)
		), 

@@ .. locked?
		setq( i, 
			if( lock( %0 ), 
				setunion(%qi, locked, |)
			)
		), 

		ansi( 
			xh, %b Exit , 
			xh, if( t(%qi), %b %([u( .itemize, %qi, |, %, )]%) ), 
			xh, :%b
		
		), 

		name( %0 ), %b%(, %0, %)%r, 

		ansi( xh, %b %b Leads To:%b ), name( loc( %0 )), %b%(, loc( %0 ), %)%b, 

@@ .. ignoring notes on exits until a better way presents itself

	)
)


--------------------------------------------------------------------------------
-- FILTER: Player Owns item ----------------------------------------------------

	filter(filter.owned-by-player, <exit list>, , , <owner dbref>)

0: exit dbref
1: owner dbref

--

&filter.owned-by-player fmo=strmatch(owner(%0), %1)


--------------------------------------------------------------------------------
-- REPORT: Report on (other) Exits ---------------------------------------------

These are meant to be exits owned by a player, but are not in a room that they own.

0: list of exits

--

&report.other-exits fmo=
localize( 
	iter( %0, 
@@ for each exit ...
		strcat( 
@@ .. source room
			u( .divider, OTHER ROOM: [name( home( %i0 ))] ([home( %i0 )]) ), %r, 
@@ .. exit details
			u( report.room-exit, %i0 )

		), 
		, @@
	)
)

--

think [setq(0, #3225)][setq(r, search(%q0 type=rooms))][setq(e, search(%q0 type=exits))][setq(o, iter(%qr, filter(#1642/filter.owned-by-player, lexits(%i0), , , %q0)))][u(#1642/report.other-exits, setdiff(%qe, %qo))]

think [setq(0, pmatch(meadow))][setq(r, search(%q0 type=rooms))][setq(e, search(%q0 type=exits))][setq(o, iter(%qr, filter(#1642/filter.owned-by-player, lexits(%i0), , , %q0)))][u(#1642/report.other-exits, setdiff(%qe, %qo))]


--------------------------------------------------------------------------------
-- FUNCTION: Report on Objects -------------------------------------------------

0: list of objects
1: owner dbref
2: viewed-by dbref (optional, defaults to %0)

x: viewer is 'staffer' or 'player' - viewer defaults to target
i: 'if' condition looking for at the moment so it can be reported

--

&report.objects fmo=
localize(
	strcat( 
		setq( x, if( u( .isstaff, if( t( %2 ), %2, %1 )), staffer, player )), 
		u( .superheader, OBJECTS ), %r, 

@@ for each object ...
		iter( %0, 
			strcat( 

@@ .. name/dbref
				u( .header, [name(%i0)] (%i0) ), %r, 

@@ .. home
				ansi( h, %b Home:%b ), 
				name( home( %i0 )), %b%(, home( %i0 ), %)%r, 

@@ .. exit report
				if( t(setr( i, lexits( %i0 ))), 
					cat( %b Object has, words( %i0 ), exits. )
				), 

@@ notes/views/etc
				ulocal( report.notes, %i0, %qx, Notes, divider), 

@@ linkages
				ulocal( report.linkages, %0, divider ), 

				u( .footer )
			), 
			, %r
		), 
		%r, 
		u( .superfooter, [words(%0)] Objects )
	)
)

================================================================================
== NOTES =======================================================================

Interfaces to Ebla's Notes system

--

&prefix.ebla's_notes fmo=notes.


--------------------------------------------------------------------------------
-- FUNCTION: List Notes Attributes ---------------------------------------------

'player': list '_notes' and '_views'
'staff': list '_staffnotes 
'both', concat both lists

'notes': list '_notes'
'views': list '_views'
'staffnotes': list '_staffnotes'

returns list of attributes

--

0: target dbref
1: 'player', 'staff', 'both'

--

&notes.list-notes-attrs fmo=
	case( %1, 
		views, lattr( %0/_view_* ), 
		notes, lattr( %0/_note_* ), 
		staffnotes, lattr( %0/_staffnote_* ), 
		
		player, 
		setunion( 
			u( notes.list-notes-attrs, %0, views ), 
			u( notes.list-notes-attrs, %0, notes ) 
		), 

		staff, 
		u( notes.list-notes-attrs, %0, staffnotes ), 

		staffer, 
		cat( 
			u( notes.list-notes-attrs, %0, player ), 
			u( notes.list-notes-attrs, %0, staff )
		), 

		both, 
		cat( 
			u( notes.list-notes-attrs, %0, player ), 
			u( notes.list-notes-attrs, %0, staff )
		)
	)


--------------------------------------------------------------------------------
-- FUNCTION: Get Note Text -----------------------------------------------------

0: target dbref
1: attribtue

--

&notes.text fmo=extract( get( %0/%1 ),  9, 999999, | )


--------------------------------------------------------------------------------
-- FUNCTION: Get Note Title ----------------------------------------------------

0: target dbref (_notes_<title>, et al.)
1: attribtue
returns: <view type>: <title>

--

&notes.title fmo=titlestr(edit( ansi( nr, elements( %1, 2, _ ):%b,  n, rest( rest( %1, _ ), _ )), _, %b ))



================================================================================
== S.A.S.S =====================================================================

Supernatural Agreement Support System: Pledges, pacts, blood-baths and so forth.
Unfortunately the system isn't complete just yet, so we'll be doing stuff by hand for now.

--

&prefix.s.a.s.s fmo=sass.
&d.sass.databases fmo=#2893 #4620 #8451 #10522


--------------------------------------------------------------------------------
-- S.A.S.S: List Items ---------------------------------------------------------

0: player dbref
output: <item>:<number>:<name>|<number>:<name>||<item>: ..
<item>: Pledges, Blood Baths, etc.

--

&sass.list-items fmo=
	filter( sass.filter.list-items, 
		iter( v( d.sass.databases ), 
			[before( name( %i0 ), %bDatabase)]:
			[sortby( 
				sass.sortby.items-by-num, 
				[iter( grepi( %i0, *, %0 ), 
					[rest( %i0, . )]:[first( get( %i1/%i0 ), | )], , | 
				)], 
				|, |
			)], , || 
		), ||, || 
	)

--

think u(fmo/sass.list-items, pmatch(kelvin))


--------------------------------------------------------------------------------
-- S.A.S.S: Filter List Items --------------------------------------------------

0: list of items in the 'list items' format: <type>:<item>|<item>
returns: Only <type>s with <item>s in it

--

&sass.filter.list-items fmo=t( words( rest( %0, : ), | ))


--------------------------------------------------------------------------------
-- S.A.S.S: Sort Items by Number -----------------------------------------------

	sortby( sass.sortby.items-by-num, <num>:<title>|<num>: ..., |, | )

0: <num>:<title>

--

&sass.sortby.items-by-num fmo=sub( first( %0, : ), first( %1, : ))









think [setq(1, pmatch(xenos))][u(fmo/report.player, %q1)]%r[u(fmo/report.rooms, search( %q1 type=room ))]%r[u(fmo/report.objects, search( %q1 type=object ))]

, setr( n, u( fmo/notes.list-notes-attrs, %q1, player )), setr( i, u( fmo/notes.list-notes-attrs, %q1, staff )))]






_NOTE_LIBRARY [#1154]: 1335106715|#10082|approved|1335106727|#10082|locked|1335106732|#10082|.....




-- f.freezer.room.public ----

0: room dbref

	Name
	Dbref
	&owner
	&coords
	notes

-- f.freezer.room.staff ----
	Name
	Dbref
	staffnotes
	+dir reminder


--------------------------------------------------------------------------------
-- f.freezer.room.cords --------------------------------------------------------

&f.freezer.room.cords #xxx=ucstr( get( %0/coords ))




