================================================================================
== PLANNING ====================================================================


--------------------------------------------------------------------------------
-- PLANNING: Outline -----------------------------------------------------------

FACTIONS REWRITE FROM COMPLETE AND TOTAL SCRATCH

The purpose of this project is to replace the tried-and-true, but much-aged Aether Factions system (originally written for TinyMUSH 3.2).

This may be a mid-step between an all-Mu* setup and an SQL system.

Actions apply <faction> to <player>
	+faction/add <player>=<faction>
	+faction/title <player>/<faction>=<title>


--------------------------------------------------------------------------------
-- PLANNING: API ---------------------------------------------------------------

A usable function-based API is a must.  I'll be doing my favorite method:
	faction(<action>, <input>)

e.g.: faction(factions[, <partial faction name>])
      faction(list, <faction name>)
      faction(details, <faction name>[, <player name>])
      faction(add, <player name>, <faction name>)


--------------------------------------------------------------------------------
-- PLANNING: Cross-Platform ----------------------------------------------------

All user-defined or cross-platform function issues should (should, mind you) go in their own function class.

	&.<function name>


-- TEMPORARY NOTES -------------------------------------------------------------

Coventry says:
	trim( squish( iter( %0, if( strmatch( %i0, %1 ), %i0 ), %2, %2 ), %2 ), %2 )

... as a filter for matching dbref to name.  
(will need: strmatch( name( %i0 ), %1)

Use with list/who


--------------------------------------------------------------------------------
-- PLANNING: Actions & Queries -------------------------------------------------

NOTE TO SELF: Can add factions to another faction
	- Loop-check
	- Permissions inherit?  Override?

Lists return dbrefs unless mentioned otherwise.
Items in (parenthesis) are the defaults for that command.

System Actions/Queries - 
√	factions: [<faction name>]
		Returns the dbref(s) of all factions or matching factions
√	gget: <item|list>
		Return the value of a global default setting(s).
		- in these 'get' cases, return |-delim list of values. e.g.:
		- faction(globals, active title) -> 64|<null>
√	gset: <item>, <value>
		Set a global default setting.  If null, erase.
		** Wizard Only **
		- active: Days until a player is considered inactive (default: 30)
		- power: The default member power level (default: member)
		- rank: The default member numeric rank (default: null)
		- title: The default member title (default: null)
		- category: The default faction category (default: null)
	powers: [<name filter>]
		List (all) possible access level powers

Faction Actions/Queries - 
√	create: <faction>
		Creates a faction.
	destroy: <faction>[, YES]
		Remove the faction.
√	fget: <faction>, <item|list>
√	fset: <faction>, <item>, <value>
		Change the default for this faction. See 'gget/gset', above.
		- description: A decription of the faction
		- permission.view (???): A permission on who's allowed to see the 
		  faction.
√	roster: <faction>[, active|inactive|all]
		List all (default: active) faction members.
√	who: <faction>[, active|inactive|all]
		List connected (default: active) faction members.
	mail: <faction>, <title>[, active|inactive|all]
		Starts a @mail to all (active) faction members.
	clean: <faction>
		Force an "allowed to RP" check for members of the faction.

Member Actions/Queries - 
√	add: <member>, <faction>
		Add member to a faction. (Faction may be inactive.)
		@mail player if they can see the faction (e.g., not double-blind).
√	remove: <member>, <faction>[, YES]
		Completely remove a member from a faction. (Faction may be inactive.)
√	mget: <member>, <faction>, <item|list>
		Return the value(s) of a faction member's setting
√	mset: <member>, <faction>, <item>[, <value>]
		Set a faction member's setting.  If null, set to null/default
		- power: Numeric power level of a member: Null -> default
		- rank: The numeric rank
		- title: The title
√	memberof: <member>[, <faction name>]
		List all factions (filtered by <faction name> a member is a part of.
		(add 'isfaction()' -> action.memberof, <member>, <faction name> 
		for backwards compatability)


--------------------------------------------------------------------------------
-- PLANNING: Access Privs ------------------------------------------------------

Options:
	faction:<faction> - is in
	attribute:<attr> - has
	attribute:<attr>:<value> - has at value
	stat:<stat> - has
	stat:<stat>:<value> - stat is >= <value>
	stat:<stat>::<string> - has stat (substat)
	flag:<flag> - has
	template:<template> - is
	sphere:<sphere> - is in
	location:<location> - is in

Usage:
	<access>|<access>|<access>

e.g.:
	attribute:sees_spirits|faction:spirit

Uses the Access System Fob (#3233 on The Reach).  General usage is applying the player to the access rules.  Multiple rules are 'or', returns true if any are true.

	
--------------------------------------------------------------------------------
-- PLANNING: Data Dictionary ---------------------------------------------------

* Faction Parent
(global defaults)

&member.active
	Days until a player is considered 'inactive'.  This is different than a 
	frozen player, who is always inactive.  A frozen player is determined by the 
	game.  The default default is '30'.

&member.power
	The default power level for new members.  The default is 'member'.

&member.rank
	The default numeric rank for new members.  The default is <null>.

&member.title
	The default title for new members.  The default is <null>.

&faction.category
	The faction's main category (for listing)

&faction.permission.<type>
	Permission of type <type>
	- view: Who can see this faction. If 'faction:!<faction name>', nobody can
	- ??? (don't know how this will work)

&d.powers
	A list of valid member power levels
	- member: Nothing special, normal member
	- view: Member who can view faction even with double-blind
	- admin: View rights plus can edit, add & remove members, staff are admin
	- (may not be changable from within the system)

--

* Faction Object

All the defaults (&faction./&member.) can be altered for a faction.

@name
	Name of the faction

@description
	Base information about the faction

Parented items (may be changed per-faction):
	member.active, member.power, member.rank, member.title, faction.active, 
	faction.category, faction.permission.<type> (???)

--

* Member Info (on Faction Object)

&member.power.<dbref>
	Power/responsibility level (admin/member)
	Must not be null; its existence says <dbref> is faction member

&member.title.<dbref>
	Faction title for <dbref>. Max length: 30 characters. If title is null, use faction default in display.

&member.rank.<dbref>
	Faction rank of <dbref>. Numeric, -999 to 999, determines faction's primary sort order. If rank is null, use faction default in display.

&member.title.default
	Allows a default (formula) for title

&member.rank.default
	Allows a default (formula) for rank

--

The system will determine if to use title/rank defaults thus:

	udefault(<faction>/member.<element>.<dbref>, 
		u(<faction>/member.<element>, <dbref>)
	)

e.g.
	udefault(#xxx/member.title.#yyy, u(#xxx/member.title, #yyy))

This will allow formulae in the title and rank to grab player information, if necessary.

--

Faction defaults will happen naturally, as the @parenting will read higher up.


================================================================================
== FACTIONS ====================================================================

@create Faction Groups <fg>=10
@desc Faction Groups=A system to list people by their affiliation(s)

@set Faction Groups=inherit
@set Faction Groups=safe

@parent Faction Groups=codp
&prefix.cross_platform Faction Groups=.
&prefix.user_function_actions Faction Groups=action.

--

@create Faction Parent=10
@desc Faction Parent=Please replace this with basic information about the faction!
@fo me=&d.faction_parent Faction Groups=[num(Faction Parent)]

@parent Faction Parent=codp

@@ >> global functions -- null defaults are reminders that they exist

&member.active Faction Parent=30
&member.power Faction Parent=member
&member.rank Faction Parent=
&member.title Faction Parent=
&faction.permission.view Faction Parent=
&faction.active Faction Parent=1

@tel Faction Parent=Faction Groups


--------------------------------------------------------------------------------
-- FUNCTION: Cross-Platform Functions ------------------------------------------

&.header Faction Groups=wheader(%0)
&.footer Faction Groups=wfooter(%0)
&.divider Faction Groups=wdivider(%0)

&.msg Faction Groups=msg(h, %0, %1)

&.isstaff Faction Groups=isstaff(%0)

&.iswiz Faction Groups=hasflag(%0, WIZARD)

&.isapproved Faction Groups=isapproved(%0)

&.crumple Faction Groups=trim(squish(%0))

&.active Faction Groups=active(%0)

@@ how does your game determine that someone is valid to RP?
@@ (we use 'is approved')

&.rp_ok Faction Groups=u(.isapproved, %0)


--------------------------------------------------------------------------------
-- DATA: Important Set-Up Data -------------------------------------------------

&d.one-day Faction Groups=86400

&d.powers Faction Parent=member|view|admin

&d.settable_defaults Faction Groups=
	member.active 
	member.power 
	member.rank 
	member.title 
	faction.category 
	faction.active 
	description


================================================================================
== COMMAND SETUP ===============================================================

The "Mistress System" funnels everything through a single command.  For this command, like many others, an optional 's' on it is valid.  e.g., faction/factions.

	+command(s) -> &c.<command>.default
	+command(s) <stuff> -> &c.<command>.specific
	+command(s)/switches [<stuff>] -> &c.<command>/<switch>

To each of these (including the first), the following are passed:
	%0: <stuff>
	%1: </other/switches>

In the case of the switches, the first valid switch has their command called, if all switches are invalid we call &c.<name>.default or &c.<name>.specific, depending on the above rules.

--

&c.factions Faction Groups=$faction*:@pemit %#=
	[setq(n, factions)]
	[switch(%0, 
@@ Without 's' ending
		, u(c.%qn.default), 
		/*, u(c.%qn.switch, first(%0), rest(%0)), 
		%b*, u(c.%qn.specific, trim(%0)), 

@@ With 's' ending
		s, u(c.%qn.default), 
		s/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), 
		s%b*, u(c.%qn.specific, trim(rest(%0))), 

@@ No match
		Error: I don't know what you mean. Please see [ansi(h, +help %qn)]
	)]


--------------------------------------------------------------------------------
-- factions/<switch> -----------------------------------------------------------

Handles all /switches, which is to say it makes sure they exist and passes them on.

Also handles pseudo-switches, passing them on as elements to any switched item.

Passes to &c.<name>.specific (%1, %qp) or &c.<name>/<switch> (%1, %qp), even if %1 is empty.

--

0: /<switch>[/<switch>/<switch>, etc.]
1: [<more>], stuff to pass to c.<name>/<switch>, if any
qn: Name of the command, global register set in &c.<name> (above)

qa: all c.<name>/* on this object
qs: /valid/command/switches/found
qp: /pseudo/switches/found, pass to c.<name>[/<switch>]

--

&c.factions.switch Faction Groups=
	[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))]
	[iter(rest(%0, /), 
		if(
			t(grab(%qa, c.%qn/%i0*)), 
			setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), 
			setq(p, %qp/%i0)
		), 
		/, @@
	)]
	[if(t(%qs), 
		ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), 
		if(t(%1), 
			ulocal(c.%qn.specific, %1, %qp), 
			ulocal(c.%qn.default, %1, %qp)
		)
	)]


--------------------------------------------------------------------------------
-- factions (default) ----------------------------------------------------------

Show default factions setup: List factions

--

0: passed by fake /switches, ignored
1: fake /switches, error

--

&c.factions.default Faction Groups=if(strlen(%1), u(.msg, factions, Factions doesn't take that switch. See +help factions), u(c.factions/default))


--------------------------------------------------------------------------------
-- factions <stuff> (specific) -------------------------------------------------

Show information about a particular faction

--

0: faction name or dbref
1: fake /switches, errored

--

&c.factions.specific Faction Groups=if(strlen(%1), u(.msg, factions, Factions doesn't take that switch. See +help factions), u(c.factions/faction))


--------------------------------------------------------------------------------
-- factions/list ---------------------------------------------------------------

&c.factions/list Faction Groups=Factions/List


--------------------------------------------------------------------------------
-- factions/faction ------------------------------------------------------------

&c.factions/faction Faction Groups=Factions/faction



================================================================================
== ACTIONS =====================================================================

<see planning, above, for the actions/queries list>


--------------------------------------------------------------------------------
-- ACTION: Global Info: Get (system) -------------------------------------------

	faction(gget, <item|list>)

If <item|list> is null, display valid <items|>

--

&action.gget Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.isstaff, %@), 
		#-1 Staff only, 

		u(f.global_get, v(d.faction_parent), %0)
	)
)

--

think u(fg/action.gget)
think u(fg/action.gget, u(fg/action.gget))

think u(fg/action.gget, u(fg/action.gget)|tester)


--------------------------------------------------------------------------------
-- ACTION: Global Info: Set (system) -------------------------------------------

	faction(gset, <item>, <value>|NULL)

For the sake of security at this level, may only be invoked by a wizard.

if <item> is empty, show valid <item|>s. (consistent with &action.mset)
If <value> is empty, clear.

--

&action.gset Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.iswiz, %@), 
		#-1 Wizard only, 
		
		u(f.global_set, v(d.faction_parent), %0, %1)
	)
)

--

think u(fg/action.gset)
think u(fg/action.gset, u(fg/action.gget))

think u(fg/action.gset, u(fg/action.gget)|tester)


--------------------------------------------------------------------------------
-- ACTION: Faction Info: Get (system) ------------------------------------------

	faction(fget, <faction>, <item|list>)

f: faction(s) dbref match

If <item|list> is null, display valid <items|>

--

&action.fget Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.isstaff, %@), 
		#-1 Staff only, 

@@ .. faction check
@@ .. (ok if %1 is blank - order of operations is important!)
		cor(t(setr(f, u(action.factions, %0))), not(comp(%1, ))), 
		#-1 Faction '%0' not found, 

		cor(lte(words(%qf), 1), not(comp(%1, ))), 
		#-1 Multiple faction matches, 

@@ ok to get
		u(f.global_get, %qf, %1)
	)
)

--

think u(fg/action.fget)
think u(fg/action.fget, test, u(fg/action.fget))

think u(fg/action.fget, oogle, random|stuff)
think u(fg/action.fget, test, u(fg/action.gget)|tester)


--------------------------------------------------------------------------------
-- ACTION: Faction Info: Set (system) ------------------------------------------

	faction(fset, <faction>, <item>, <value>)

f: faction(s) dbref match

If <item|list> is null, display valid <items|>

--

&action.fset Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.isstaff, %@), 
		#-1 Staff only, 

@@ .. faction check
@@ .. (ok if %1 is blank - order of operations is important!)
		cor(t(setr(f, u(action.factions, %0))), not(comp(%1, ))), 
		#-1 Faction '%0' not found, 

		cor(lte(words(%qf), 1), not(comp(%1, ))), 
		#-1 Multiple faction matches, 

@@ ok to get
		u(f.global_set, %qf, %1, %2)
	)
)

--

think u(fg/action.fset, test, description, Oook ook!)
ex u(fg/action.factions, test)/desc

think u(fg/action.fset, test, description, This is a faction! For testing!)
ex u(fg/action.factions, test)/desc

think u(fg/action.fset, test, faction.active, 0)
ex u(fg/action.factions, test)/faction.active

think u(fg/action.fset, test, faction.active, 1)
think u(fg/action.fset, test, faction.active, )
ex u(fg/action.factions, test)/faction.active

think u(fg/action.fset, test, faction.active, 1)
think u(fg/action.fset, test, faction.active, yes)
think u(fg/action.fset, test, faction.active, no)
ex u(fg/action.factions, test)/faction.active


--------------------------------------------------------------------------------
-- ACTION: Factions List (system) ----------------------------------------------

List factions as appropriate for a certain player, which means throwing it through one or more filters.

	faction(factions[, <faction name>])

--

&action.factions Faction Groups=
	filter(fil.factions_byname, 
		filter(fil.cansee_factions, 
			filter(fil.valid_factions, lcon(%!)), 
			@@(idelim), @@(odelim), 
			%#
		), 
		@@(idelim), @@(odelim), 
		%0
	)

--

think u(fg/action.factions)
think u(fg/action.factions, *est*)


--------------------------------------------------------------------------------
-- ACTION: Create Faction (system) ---------------------------------------------

	faction(create, <faction name>)

f: faction dbref
m: exsting faction that matches on first 5 characters as %0

Returns: #-1 <error> or dbref.

--

&action.create Faction Groups=
localize(
	case(0, 

@@ .. staff only
		t(u(.isstaff, %@)), 
		#-1 Staff only, 

@@ .. check for valid faction object name
		valid(name, %0), 
		#-1 That's a bad name for a faction, 

@@ .. check for existing close-enough faction name (first 5 character match)
		not(setr(m, 
			grab(
				iter(filter(fil.valid_factions, lcon(%!)), name(%i0), , |), 
				[strtrunc(%0, 5)]*, 
				|
			)
		)), 
		#-1 A similar faction name already exists as '%qm', 

@@ .. check created alright
		t(setr(f, create(%0, ))), 
		#-1 Error when creating faction '%0', 

@@ .. check parented alright
		strcat(parent(%qf, v(d.faction_parent)), strmatch(parent(%qf), v(d.faction_parent))), 
		#-1 Error when setting faction parent. 
		Please type: @parent %qf=[v(d.faction_parent)], 

@@ .. ok: return object dbref
		%qf
	)
)

--

think u(fg/action.create, Test Fallacy)


--------------------------------------------------------------------------------
-- ACTION: Details About a Faction (faction) -----------------------------------

	faction(details, <faction>[, <player dbref>])

f: faction dbref
p: player dbref, if passed

note: | is a protected symbol here, but we'll keep things that could use it
	  at the end of the returned information

--

&action.details Faction Groups=
localize(
	case(0, 

@@ .. faction checks
		t(setr(f, u(action.factions, %0))), 
		#-1 Faction '%0' not found, 

		eq(words(%qf), 1), 
		#-1 Too many matching factions found, 

@@ >> faction details (no player dbref passed): 
@@ .. <dbref>|<member dbrefs>|<permissions>|<desc>
		strlen(%1), 
		%qf|
		[iter(lattr(%qf/member.power.*), last(%i0, .))]|
		[get(%qf/permissions.view)]|
		[get(%qf/desc)]|, 

@@ .. player checks 
		t(setr(p, pmatch(%1))), 
		#-1 Player '%1' has too many matches or not found, 

		t(get(%qf/member.power.%qp)), 
		#-1 Player '[name(%qp)]' not a member of faction '[name(%qf)]', 

@@ >> player details
@@ .. <dbref>|<power>|<rank>|<title>
@@ .. (<rank> and <title> may be determined via code on faction or parent)
		%qp|
		[get(%qf/member.power.%qp)]|
		[udefault(%qf/member.rank.%qp, u(%qf/default.rank, %qp))]|
		[udefault(%qf/member.title.%qp, u(%qf/default.title, %qp))]
	)
)

--

think u(fg/action.details, test fac)
think u(fg/action.details, test fac, thenomain)


--------------------------------------------------------------------------------
-- ACTION: Add Player to Faction (individual) ----------------------------------

	faction(add, <player>, <faction>)

p: dbref of player to add
f: faction dbref

e: possible error from functions: set()

--

&action.add Faction Groups=
localize(
	case(0, 
@@ .. basic checks
@@ >> staff or Power:Admin, not staff-only
		u(.isstaff, %@), 
		#-1 Staff only, 

		t(setr(p, pmatch(%0))), 
		#-1 Player '%0' not found, 

		t(u(.isapproved, %qp)), 
		#-1 Player is not approved for RP, 

		t(setr(f, u(action.factions, %1))), 
		#-1 Faction '%1' not found, 

		eq(words(%qf), 1), 
		#-1 Multiple faction matches, 

		not(hasattr(%qf, member.power.%qp)), 
		#-1 '[name(%qp)]' is already member of faction '[name(%qf)]', 

@@ .. generic error
		eq(strlen(setr(e, set(%qf, member.power.%qp:[u(%qf/member.power)]))), 0), 
		#-1 %qe, 

@@ OK
		1
	)
)

--

think u(fg/action.add, *thenomain, test)


--------------------------------------------------------------------------------
-- ACTION: Member Info: Set (individual) ---------------------------------------

	faction(mset, <player>, <faction>, <element>[, <entry>])

p: dbref of player to add
f: faction dbref
a: attribute to set

If <entry> is null, use faction default in display.

--

&action.mset Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.isstaff, %@), 
		#-1 Staff only, 

@@ .. (if <player> is empty, show valid <elements|>)
		gt(strlen(%1), 0), 
		lcstr(edit(sort(lattr(%!/f.mset.*), , , |), F.MSET., , _, %b)), 

		t(setr(f, u(action.factions, %1))), 
		#-1 Faction '%1' not found, 

		eq(words(%qf), 1), 
		#-1 Multiple faction matches, 
		
		t(setr(p, pmatch(%0))), 
		#-1 '%0' is not a valid player name, 

		hasattr(%qf, member.power.%qp), 
		#-1 '[name(%qp)]' is not a member of faction '[name(%qf)]', 

		t(setr(a, lattr(%!/f.mset.%2*))), 
		#-1 Mset for '%2' not found, 

		eq(words(%qa), 1), 
		#-1 Multiple set-item matches, 

@@ .. ok to set
		u(%qa, %qp, %qf, %3)
	)
)

--

think u(fg/action.mset, *thenomain, test, title, \[title\])
think u([first(u(fg/action.details, test), |)]/member.title.[pmatch(thenomain)])

think u(fg/action.mset, *thenomain, test, rank, \[title\])
think u(fg/action.mset, *thenomain, test, rank, 1500)

think u(fg/action.mset, *thenomain, test, rank, 15)
think u([first(u(fg/action.details, test), |)]/member.rank.[pmatch(thenomain)])

think u(fg/action.mset, *thenomain, test, power, 15)

think u(fg/action.mset, *thenomain, test, power, ad)
think u([first(u(fg/action.details, test), |)]/member.power.[pmatch(thenomain)])


--------------------------------------------------------------------------------
-- ACTION: Member Info: Get (individual) ---------------------------------------

	faction(mset, <player>, <faction>, <item|list>)

p: player dbref
f: faction dbref

If <entry> is null, use faction default in display.

If <player> is null, display valid <items|>

--

&action.mget Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.isstaff, %@), 
		#-1 Staff only, 

@@ .. (if <player> is empty, show valid <elements|>)
		gt(strlen(%1), 0), 
		lcstr(edit(sort(lattr(%!/f.mget.*), , , |), F.MGET., , _, %b)), 

@@ .. faction check
		t(setr(f, u(action.factions, %1))), 
		#-1 Faction '%1' not found, 

		eq(words(%qf), 1), 
		#-1 Multiple faction matches, 
		
		t(setr(p, pmatch(%0))), 
		#-1 '%0' is not a valid player name, 

		hasattr(%qf, member.power.%qp), 
		#-1 '[name(%qp)]' is not a member of faction '[name(%qf)]', 

@@ .. ok to get
		iter(%2, 
			udefault(
				first(sort(lattr(%!/f.mget.%i0*))), 
				#-1 %i0, 
				%qp, %qf, 
			), 
			|, |
		)
	)
)

--

think u(fg/action.mget, *thenomain, test, title)
think u(fg/action.mget, *thenomain, test, rank)
think u(fg/action.mget, *thenomain, test, power)

think u(fg/action.mget, *thenomain, test, u(fg/action.mget))

think u(fg/action.mget, *thenomain, test, title|flange|power)


--------------------------------------------------------------------------------
-- ACTION: Remove Player from Faction (individual) -----------------------------

	faction(remove, <player>, <faction>[, YES])

p: player dbref
f: faction dbref

--

&action.remove Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.isstaff, %@), 
		#-1 Staff only, 

@@ .. player checks 
		t(setr(p, pmatch(%0))), 
		#-1 Player '%0' has too many matches or not found, 

		hasattr(%qf, member.power.%qp), 
		#-1 Player '[name(%qp)]' not a member of faction '[name(%qf)]', 

@@ .. faction checks
		t(setr(f, u(action.factions, %1))), 
		#-1 Faction '%1' not found, 

		eq(words(%qf), 1), 
		#-1 Too many matching factions found, 

@@ .. "YES" double-check
		not(comp(%2, YES)), 
		#-1 Verify removing this member with 'YES',

@@ .. ok: wipe attributes and return '1'
		null(iter(lattr(%qf/member.*.%qp), set(%qf, %i0:)))
		1
	)
)

--

think u(fg/action.remove, *thenomain, testfd)


--------------------------------------------------------------------------------
-- ACTION: List Factions Player is Member Of (individual) ----------------------

	faction(memberof, <player>[, <faction name>])

Nested filters:
	valid factions -> name filter (optional) -> can-see filter -> member filter

--

&action.memberof Faction Groups=

filter(fil.member.of, 
	filter(fil.cansee_factions, 
		filter(fil.factions_byname, 
			filter(fil.valid_factions, 
			lcon(%!)
		), 
			, , %1*
		), 
		, , %@
	), 
	, , pmatch(%0)
)

--

think u(fg/action.memberof, anderson)
think u(fg/action.memberof, thenomain)
think u(fg/action.memberof, thenomain, *est*)


--------------------------------------------------------------------------------
-- ACTION: Roster of Faction (faction) -----------------------------------------

	faction(roster, <faction name>[, active|inactive|all])

f: faction dbref
w: words(<faction dbref(s)>)
a: activity
r: roster dbrefs
l: roster's player list

--

&action.roster Faction Groups=
localize( 
	strcat( 
		setq( a, 
			switch( %1, 
				ac*, active, 
				i*, inactive, 
				al*, all, 
				active
			)
		), 
		case( 0, 

			strlen( setr( f, u( action.factions, %0 ))), 
			#-1 No factions found, 
	
			eq( setr( w, words( %qf )), 1 ), 
			#-1 %qw factions found, 

			strcat( 
				setq( l, u( f.members.list, %qf )), 
				case( 0, 
@@ .. active
					comp( %qa, active ), 
					filter( fil.active_players, %ql, , , %qf ), 

@@ .. inactive
					comp( %qa, inactive ), 
					setdiff( 
						%ql, 
						filter( fil.active_players, %ql, , , %qf )
					), 

@@ .. all
					comp( %qa, all ), 
					%ql 
				)
			)
		)
	)
)

--

think u(fg/action.roster, test)

think u(fg/action.roster, fd)

think u(fg/action.roster)


--------------------------------------------------------------------------------
-- ACTION: Faction Who (faction) -----------------------------------------------

	faction(who, <faction name>[, active|inactive|all])

Mainly calls 'roster', above.

--

&action.who Faction Groups=
localize( 
	strcat( 
		setq( r, u( action.roster, %0, %1 )), 
		case( 1, 
			strmatch( %qr, #-1* ), %qr, 
			filter( fil.connected, %qr )
		)
	)
)

--

think u(fg/action.who, test)



================================================================================
== FILTERS =====================================================================


--------------------------------------------------------------------------------
-- FILTER: Valid Factions ------------------------------------------------------

Filters a list of dbrefs and returns those that meet the 'valid faction' criteria, for a bit of security.

Sample Usage: filter( fil.valid_factions, lcon( %! ))

--

&fil.valid_factions Faction Groups=and(strmatch(loc(%0), %!), strmatch(parent(%0), v(d.faction_parent)))


--------------------------------------------------------------------------------
-- FILTER: Cansee Factions -----------------------------------------------------

Filters a list of dbrefs (should be checked as 'valid factions') to only the ones that a player can see.

Sample Usage: 
	filter(fil.cansee_factions, filter(fil.valid_factions, lcon(%!)), , , %#)

(Basic Initial Code: Belongs to group or is staff)

--

&fil.cansee_factions Faction Groups=
	cor(
		u(.isstaff, %1), 
		hasattr(%0, member.power.%1)
	)


--------------------------------------------------------------------------------
-- FILTER: Faction Name Filter -------------------------------------------------

Filters a list of dbrefs (should be checked as 'valid factions') to only the ones matching a particular name.

Sample Usage: 
	filter(fil.factions_byname, filter(fil.valid_factions, lcon(%!)), , , *est*)

--

&fil.factions_byname Faction Groups=strmatch(name(%0), %1*)


--------------------------------------------------------------------------------
-- FILTER: List of factions someone is a member of -----------------------------

Sample Usage:
	filter(fil.member.of, filter(fil.valid_factions, lcon(%!)), , , pmatch(thenomain))


--

&fil.member.of Faction Groups=hasattr(%0, member.power.%1)


--------------------------------------------------------------------------------
-- FILTER: Active Players in Faction -------------------------------------------

	u(fil.active_players, <player dbref>, <faction dbref>)
	filter(fil.active_players, <player list>, , , <faction dbref>)

0: list of player dbrefs
1: faction dbref (for pulling its 'active' default)

--

&fil.active_players Faction Groups=
	lte( 
		u( .active, %0 ), 
		mul( get( %1/member.active ), v( d.one-day ))
	)

--

think u(fg/fil.active_players, pmatch(thenomain), u(fg/action.factions, test))

think filter(fg/fil.active_players, <roster>, , , u(fg/action.factions, test))

think setdiff(<roster>, filter(fg/fil.active_players, <roster>, , , u(fg/action.factions, test)))

--------------------------------------------------------------------------------
-- FILTER: Active Players in Faction -------------------------------------------

	filter( fil.connected, <player list> )

Pretty straightforward.

--

&fil.connected Faction Groups=hasflag( %0, connect )


================================================================================
== INTERNAL FUNCTIONS ==========================================================

--------------------------------------------------------------------------------
-- FUNCTION: List Members of Faction -------------------------------------------

List all player dbrefs of a particular faction

0: Faction dbref - assumed valid

--

&f.members.list Faction Groups=
	sort(
		edit(
			lattr( %0/MEMBER.POWER.* ), 
			MEMBER.POWER., 
			@@( null )
		)
	)

--

think u(fg/f.members.list, u(fg/action.factions, test))


--------------------------------------------------------------------------------
-- FUNCTION: List Categories ---------------------------------------------------

List the categories from all (passed) faction dbrefs - not validated

0: Faction dbref list (optional)

--

&f.categories.list Faction Groups=
	setunion(
		iter(
			if(strlen(%0), 
				filter(fil.valid_factions, %0), 
				filter(fil.valid_factions, lcon(%!))
			), get(%i0/faction.category), 
			@@(null), 
			|
		), 
		@@(null), 
		|
	)

--

think u(fg/f.categories.list)
think u(fg/f.categories.list, #7673)


--------------------------------------------------------------------------------
-- FUNCTION: Member Set: Title -------------------------------------------------

0: member dbref
1: faction dbref
2: title value

&f.mset.title Faction Groups=
localize(
	case(0, 

		lte(strlen(%2), 30), 
		#-1 Title may be at most 30 characters, 

		eq(strlen(setr(e, set(%1, member.title.%0:[escape(%2)]))), 0), 
		#-1 %qe, 

@@ OK
		1
	)
)


--------------------------------------------------------------------------------
-- FUNCTION: Member Set: Rank --------------------------------------------------

0: member dbref
1: faction dbref
2: rank value

--

&f.mset.rank Faction Groups=
localize(
	case(0, 

		or(isint(%2), not(comp(, %2))), 
		#-1 Rank must be numeric or blank to clear, 

		and(gte(%2, -999), lte(%2, 999)), 
		#-1 Rank must be between -999 and 999 or blank to clear, 

		eq(strlen(setr(e, set(%1, member.rank.%0:%2))), 0), 
		#-1 %qe, 

@@ OK
		1
	)
)


--------------------------------------------------------------------------------
-- FUNCTION: Member Set: Power -------------------------------------------------

0: member dbref
1: faction dbref
2: power value ('power' must always be set!)

--

&f.mset.power Faction Groups=
localize(
	case(0, 

@@ if <power value> is null, explicitly set
		comp(, %2), 
		if(
			neq(strlen(setr(e, set(%1, 
				member.power.%0:[get(%1/member.power)]
			))), 0), 
			#-1 %qe, 
			1
		), 

		t(setr(p, grab(|[get(v(d.faction_parent)/d.powers)], %2*, |))), 
		#-1 Power type not found, 

		eq(strlen(setr(e, set(%1, member.power.%0:%qp))), 0), 
		#-1 %qe, 

@@ OK
		1
	)
)


--------------------------------------------------------------------------------
-- FUNCTION: Member Get: Title -------------------------------------------------

Read default if null

0: member dbref
1: faction dbref

--

&f.mget.title Faction Groups=ulocal(%1/member.title.%0, u(%1/member.title, %0))


--------------------------------------------------------------------------------
-- FUNCTION: Member Get: Rank --------------------------------------------------

0: member dbref
1: faction dbref

--

&f.mget.rank Faction Groups=udefault(%1/member.rank.%0, u(%1/member.rank, %0))


--------------------------------------------------------------------------------
-- FUNCTION: Member Get: Power -------------------------------------------------

0: member dbref
1: faction dbref

--

&f.mget.power Faction Groups=u(%1/member.power.%0)


--------------------------------------------------------------------------------
-- FUNCTION: Global Get: Generic -----------------------------------------------

Both gget() and fget() will use this function.

0: drebf to get from (either d.faction_parent or function) - validated
1: <item|list> - unvalidated

--

&f.global_get Faction Groups=

	case(0, 

@@ .. no <item|list>
		gt(trim(strlen(%1)), 0), 
		lcstr(sort(get(%!/d.settable_defaults), , , |)), 

@@ .. check each element against the default settable list & return
		iter(%1, 
			case(0, 
				match(v(d.settable_defaults), %i0*), #-1 %i0, 
				get(
					%0/[first(sort(lattr(v(d.faction_parent)/%i0*)))]
				)
			), 

			|, |
		)
	)


--------------------------------------------------------------------------------
-- FUNCTION: Global Set: Generic -----------------------------------------------

Both gset() and fset() will use this function.

0: drebf to get from (either d.faction_parent or function) - validated
1: <item|list> - unvalidated
2: <value> - unvalidated

p: dbref of player to add
f: faction dbref
d: valid defaults, |-delimited

If <item> is null, display names.

--

&f.global_set Faction Groups=
localize(
	case(0
		[setq(d, u(action.gget))], 

@@ .. no <item|list>
		gt(strlen(trim(%1)), 0), 
		%qd, 

		eq(words(%1, |), 1), 
		#-1 Cannot set multiple defaults, 

		words(setr(g, graball(|%qd, %1*, |, |)), |), 
		#-1 Global default '%1' not found, 

		lte(words(%qg, |), 1), 
		#-1 Multiple default item matches, 

@@ .. ok: try to call proper 'f.gset.xxx' command!
		udefault(f.gset.%qg, 
			#-1 F.GLOBAL.SET CANNOT SET '[ucstr(%qg)]'!!!, 
			%0, %2
		)
	)
)


--------------------------------------------------------------------------------
-- FUNCTION: Global Set: Description -------------------------------------------

0: target dbref - validated
1: new value - unvalidated

Description of the Faction (cannot change global default)

--

&f.gset.description Faction Groups=
	case(0, 

		comp(%0, v(d.faction_parent)), 
		#-1 Cannot change the global default description, 

		lte(strlen(%1), 120), 
		#-1 Description may be at most 120 characters, 

		eq(strlen(setr(e, set(%0, desc:[escape(%1)]))), 0), 
		#-1 Set Description: %qe, 

		1
	)

--

think u(fg/f.gset.description, #6067, Oogle Boogle!)
think u(fg/f.gset.description, #7673, Oogle Boogle!)

think u(fg/f.gset.description, #7673, This is a faction! For testing!)


--------------------------------------------------------------------------------
-- FUNCTION: Global Set: Member.Active -----------------------------------------

0: target dbref - validated
1: new value - unvalidated

How many days until a member is no longer active?

--

&f.gset.member.active Faction Groups=
	case(0, 

		cand(isint(%1), gt(%1, 0)), 
		#-1 Member.Active must be a positive non-zero integer, 

		eq(strlen(setr(e, set(%0, member.active:[escape(%1)]))), 0), 
		#-1 Set Member.Active: %qe, 

		1
	)



--------------------------------------------------------------------------------
-- FUNCTION: Global Set: Faction.Active ----------------------------------------

0: target dbref - validated
1: new value - unvalidated

Is this faction active (to be listed)? 1 for yes, 0 for no (default for null)

--

&f.gset.faction.active Faction Groups=
	case(0, 

		cor(strmatch(%1, ), strmatch(%1, 1), strmatch(%1, 0)), 
		#-1 Faction.Active must be 0%, null%, or 1, 

		eq(strlen(setr(e, set(%0, faction.active:[if(strlen(%1), %1, 0)]))), 0), 
		#-1 Set Faction.Active: %qe, 

		1
	)

--

think u(fg/action.gset, faction.active, 0)

think u(fg/action.gset, faction.active, 1)
think u(fg/action.gset, faction.active, )

think u(fg/action.gset, faction.active, yes)
think u(fg/action.gset, faction.active, no)


--------------------------------------------------------------------------------
-- FUNCTION: Global Set: ************** ----------------------------------------

CONTINUE FROM HERE!

To Do List:
	member.power 
	member.rank 
	member.title 
	faction.category 



================================================================================
== TRIGGERS ====================================================================


--------------------------------------------------------------------------------
-- TRIGGER: Mail ---------------------------------------------------------------

0: player-list
1: topic
2: message

--

&trig.mail Faction Groups=@mail/quick %0/%1=%2

--

think trigger(fg/trig.mail, %#, Test, Success!)



================================================================================
== DISPLAYS ====================================================================

