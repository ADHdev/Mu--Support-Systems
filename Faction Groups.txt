================================================================================
== PLANNING ====================================================================

--------------------------------------------------------------------------------
-- PLANNING: Outline -----------------------------------------------------------

FACTIONS REWRITE FROM COMPLETE AND TOTAL SCRATCH

The purpose of this project is to replace the tried-and-true, but much-aged Aether Factions system (originally written for TinyMUSH 3.2).

This may be a mid-step between an all-Mu* setup and an SQL system.

Actions apply <faction> to <player>
	+faction/add <player>=<faction>
	+faction/title <player>/<faction>=<title>


--------------------------------------------------------------------------------
-- PLANNING: API ---------------------------------------------------------------

A usable function-based API is a must.  I'll be doing my favorite method:
	faction(<action>, <input>)

e.g.: faction(factions[, <partial faction name>])
      faction(list, <faction name>)
      faction(details, <faction name>[, <player name>])
      faction(add, <player name>, <faction name>)


--------------------------------------------------------------------------------
-- PLANNING: Cross-Platform ----------------------------------------------------

All user-defined or cross-platform function issues should (should, mind you) go in their own function class.

	&_<function name>


--------------------------------------------------------------------------------
-- PLANNING: Actions & Queries -------------------------------------------------

NOTE TO SELF: Can add factions to another faction
	- Loop-check
	- Permissions inherit?  Override?

Lists return dbrefs unless mentioned otherwise.
Items in (parenthesis) are the defaults for that command.

System Actions/Queries - 
	default: <item>
		Return the value of a default setting.
	default: <item>, [<value>]
		Set a default setting.  If null, erase.
		- active: Days until a player is considered inactive
		- power: The default power level (should be minimum)
		- rank: The default numeric rank
		- title: The default title 
	powers: [<name filter>]
		List (all) possible access level powers

Faction Actions/Queries - 
	activate: <faction>
		Create/re-activate a faction.
	deactivate: <faction>
		Make a faction inactive.
	factions: [active|inactive|all[, <name filter>]]
		List of (all active) factions.
	roster: <faction>[, active|inactive|all]
		List all (active) faction members.
	(???): <faction>[, active|inactive|all[, <name filter>]]
		Lists (all active) faction members
	who: <faction>[, active|inactive|all]
		List connected (active) faction members.
		(add 'isfaction()' for backwards compatability)
	mail: <faction>, <title>[, active|inactive|all]
		Starts a @mail to all (active) faction members.
	clean: <faction>
		Force an activity check for members of, and the faction itself.
	fget: <faction>, <item(s)>
		Return the value(s) of a faction's setting.
	fset: <faction>, <item>[, <value>]
		Set a faction's setting.  If null, erase.
		- description: A decription of the faction
		- type: The type of faction
		- viewperms (???): A permission on who's allowed to see the faction.

Member Actions/Queries - 
	add: <member>, <faction>
		Add member to a faction (may be inactive)
	inactive: <member>, <faction>
		Make a member inactive in a faction
	mget: <member>, <faction>, <item(s)>
		Return the value(s) of a faction member's setting
	mset: <member>, <faction>, <item>[, <value>]
		Set a faction member's setting.  If null, set to null/default
		- power: Numeric power level of a member: Null -> default
		- rank: The numeric rank
		- title: The title
	mlist: <member>[, active|inactive|all]
		List all (active) factions <member> is a part of.


--------------------------------------------------------------------------------
-- PLANNING: Data Object Format ------------------------------------------------

* Faction Object Parent

NOTE: May use the aJobs approach of calling functions through the end faction.  I'm not keen on how this makes the code harder to read, but it assures faction validation has taken place.

* Faction Object

Faction objects must be inside the Faction Groups object and must be parented to the Factions Parent.  If not, do not process them.

	@name: Name of the faction
	@description: Base information about the faction
	&faction.permission.<type>: Permission of type <type>
		view: Permission formula for can see this faction
	&member.power.<dbref>: Power/responsibility level (admin/member)
		not-null, its existence says <dbref> is faction member

	&member.title.<dbref>: Faction title for <dbref>
	&member.rank.<dbref>: Faction rank of <dbref>

	&member.title.default: Allows a default (formula) for title
	&member.rank.default: Allows a default (formula) for rank


The system will determine if to use title./rank.default thus:

	udefault(<faction>/<element>.<dbref>, 
		u(<faction>/<element>.default, <dbref>)
	)


================================================================================
== FACTIONS ====================================================================

@create Faction Groups <fg>=10
@desc Faction Groups=A system to list people by their affiliation(s)

@set Faction Groups=inherit
@set Faction Groups=safe

@parent Faction Groups=codp
&prefix.cross_platform Faction Groups=_
&prefix.user_function_actions Faction Groups=action.

--

@create Faction Parent=10
@desc Faction Parent=Please replace this with basic information about the faction!
@fo me=&d.faction_parent Faction Groups=[num(Faction Parent)]

@parent Faction Parent=codp

@tel Faction Parent=Faction Groups


--------------------------------------------------------------------------------
-- FUNCTION: Cross-Platform Functions ------------------------------------------

&_header Faction Groups=wheader(%0)
&_footer Faction Groups=wfooter(%0)
&_divider Faction Groups=wdivider(%0)

&_error Faction Groups=[alert(Factions)] %0

&_isstaff Faction Groups=isstaff(%0)

&_isapproved Faction Groups=isapproved(%0)

&_crumple Faction Groups=trim(squish(%0))


--------------------------------------------------------------------------------
-- FUNCTION: Check & lookup faction/player/power level -------------------------

*** IT WAS SUGGESTED that instead of doing this, have a more robust API.  
*** Will pause on this concept to try it out.

	u(f.check.lookup, <checker dbref>, [<faction>], [<member>], [<power lvl>])

0: dbref of who's asking
1: faction name/dbref, if passed
2: member name/dbref, if passed
3: power level, if passed


Returns one or more of: 
	OK: Everything passed checks out (no other msgs)
	NULL: Nothing was passed, you dork (no other msgs)
	DENIED: Doesn't have the proper power level to check (???)

	FACTION:<dbref>/!FOUND/MULTIPLE
	
	MEMBER:<dbref>/!FOUND
	MEMBER:APPROVED/!APPROVED (only check if found)
	MEMBER:IN_FACTION/!IN_FACTION

	POWER:<code/number/whatever>/!FOUND/MULTIPLE
	MEMBER:HAS_POWER/!HAS_POWER

--

f: faction messages
m: member messages
p: power messages

--

&f.check.lookup Faction Groups=
localize(u(_crumple, 
@@ .. if nothing passed, return NULL
	if(not(or(t(%1), t(%2), t(%3))), 
		NULL, 

@@ >> FACTION
		[if(t(%1), 
			cat(
				setq(f, u(action.factions, %1)), 
				case(1, 
					words(%qf), FACTION:%qf, 
					t(%qf), FACTION:MULTIPLE, 
					FACTION:!FOUND
				)
			)
		)] 


@@ >> MEMBER
		[if(t(%2), 
			cat(
				setq(m, pmatch(%2)), 
				case(1, 
					 t(%qm), MEMBER:%qm, 
					 MEMBER:!FOUND
				), 
				if(and(t(%qm), u(_isapproved, %qm)), 
					MEMBER:APPROVED, 
					MEMBER:!APPROVED
				), 
				if(and(eq(words(%qf), 1), t(u(action.ismember, %qf, %qm))), 
					MEMBER:IN_FACTION, 
					MEMBER:!IN_FACTION
				)
			)
		)] 

@@ >> POWER
		[if(t(%3), 
			case(1, 
				xxx, 
				POWER:<name>, 
			)
		)] 

	)
))


================================================================================
== COMMAND SETUP ===============================================================

The "Mistress System" funnels everything through a single command.  For this command, like many others, an optional 's' on it is valid.  e.g., faction/factions.

	+command(s) -> &c.<command>.default
	+command(s) <stuff> -> &c.<command>.specific
	+command(s)/switches [<stuff>] -> &c.<command>/<switch>

To each of these (including the first), the following are passed:
	%0: <stuff>
	%1: </other/switches>

In the case of the switches, the first valid switch has their command called, if all switches are invalid we call &c.<name>.default or &c.<name>.specific, depending on the above rules.

--

&c.factions Faction Groups=$faction*:@pemit %#=
	[setq(n, factions)]
	[switch(%0, 
@@ Without 's' ending
		, u(c.%qn.default), 
		/*, u(c.%qn.switch, first(%0), rest(%0)), 
		%b*, u(c.%qn.specific, trim(%0)), 

@@ With 's' ending
		s, u(c.%qn.default), 
		s/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), 
		s%b*, u(c.%qn.specific, trim(rest(%0))), 

@@ No match
		Error: I don't know what you mean. Please see [ansi(h, +help %qn)]
	)]

--

&c.factions Faction Groups=$faction*:@pemit %#=[setq(n, factions)][switch(%0, , u(c.%qn.default), /*, u(c.%qn.switch, first(%0), rest(%0)), %b*, u(c.%qn.specific, trim(%0)), s, u(c.%qn.default), s/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), s%b*, u(c.%qn.specific, trim(rest(%0))), Error: I don't know what you mean. Please see [ansi(h, +help %qn)])]



--------------------------------------------------------------------------------
-- factions/<switch> -----------------------------------------------------------

Handles all /switches, which is to say it makes sure they exist and passes them on.

Also handles pseudo-switches, passing them on as elements to any switched item.

Passes to &c.<name>.specific (%1, %qp) or &c.<name>/<switch> (%1, %qp), even if %1 is empty.

--

0: /<switch>[/<switch>/<switch>, etc.]
1: [<more>], stuff to pass to c.<name>/<switch>, if any
qn: Name of the command, global register set in &c.<name> (above)

qa: all c.<name>/* on this object
qs: /valid/command/switches/found
qp: /pseudo/switches/found, pass to c.<name>[/<switch>]

--

&c.factions.switch Faction Groups=
	[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))]
	[iter(rest(%0, /), 
		if(
			t(grab(%qa, c.%qn/%i0*)), 
			setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), 
			setq(p, %qp/%i0)
		), 
		/, @@
	)]
	[if(t(%qs), 
		ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), 
		if(t(%1), 
			ulocal(c.%qn.specific, %1, %qp), 
			ulocal(c.%qn.default, %1, %qp)
		)
	)]

--

&c.factions.switch Faction Groups=[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))][iter(rest(%0, /), if(t(grab(%qa, c.%qn/%i0*)), setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), setq(p, %qp/%i0)), /, @@)][if(t(%qs), ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), if(t(%1), ulocal(c.%qn.specific, %1, %qp), ulocal(c.%qn.default, %1, %qp)))]


--------------------------------------------------------------------------------
-- factions (default) ----------------------------------------------------------

Show default factions setup: List factions

--

0: passed by fake /switches, ignored
1: fake /switches, error

--

&c.factions.default Faction Groups=if(strlen(%1), u(_error, Factions doesn't take that switch. See +help factions), u(c.factions/default))



--------------------------------------------------------------------------------
-- factions <stuff> (specific) -------------------------------------------------

Show information about a particular faction

--

0: faction name or dbref
1: fake /switches, errored

--

&c.factions.specific Faction Groups=if(strlen(%1), u(_error, Factions doesn't take that switch. See +help factions), u(c.factions/faction))


--------------------------------------------------------------------------------
-- factions/list ---------------------------------------------------------------

&c.factions/list Faction Groups=Factions/List

--------------------------------------------------------------------------------
-- factions/faction ------------------------------------------------------------

&c.factions/faction Faction Groups=Factions/Group




================================================================================
== ACTIONS =====================================================================

<see planning, above, for the actions/queries list>

--------------------------------------------------------------------------------
-- ACTION: Factions List (system) ----------------------------------------------

List factions as appropriate for a certain player, which means throwing it through one or more filters.

	faction(factions[, <faction name>])

--

&action.factions Faction Groups=
	filter(fil.factions_byname, 
		filter(fil.cansee_factions, 
			filter(fil.valid_factions, lcon(%!)), 
			@@(empty idelim), @@(empty odelim), 
			%#
		), 
		@@(empty idelim), @@(empty odelim), 
		%0
	)

--

&action.factions Faction Groups=filter(fil.factions_byname, filter(fil.cansee_factions, filter(fil.valid_factions, lcon(%!)), @@(empty idelim), @@(empty odelim), %#), @@(empty idelim), @@(empty odelim), %0)


--------------------------------------------------------------------------------
-- ACTION: Create Faction (system) ---------------------------------------------

	faction(create, <faction name>)

f: faction dbref
m: exsting faction that matches on first 5 characters as %0

Returns: #-1 <error> or dbref.

--

&action.create Faction Groups=
localize(
	case(0, 

@@ .. staff only
		t(u(_isstaff, %#)), 
		#-1 Staff only, 

@@ .. check for valid faction object name
		valid(name, %0), 
		#-1 That's a bad name for a faction, 

@@ .. check for existing close-enough faction name (first 5 character match)
		not(setr(m, 
			grab(
				iter(filter(fil.valid_factions, lcon(%!)), name(%i0), , |), 
				[strtrunc(%0, 5)]*, 
				|
			)
		)), 
		#-1 A similar faction name already exists as '%qm', 

@@ .. check created alright
		t(setr(f, create(%0, ))), 
		#-1 Error when creating faction '%0', 

@@ .. check parented alright
		strcat(parent(%qf, v(d.faction_parent)), strmatch(parent(%qf), v(d.faction_parent))), 
		#-1 Error when setting faction parent. 
		Please type: @parent %qf=[v(d.faction_parent)], 

@@ .. ok: return object dbref
		%qf
	)
)

--

&action.create Faction Groups=localize(case(0, t(u(_isstaff, %#)), #-1 Staff only, valid(name, %0), #-1 That's a bad name for a faction, not(setr(m, grab(iter(filter(fil.valid_factions, lcon(%!)), name(%i0), , |), [strtrunc(%0, 5)]*, |))), #-1 A similar faction name already exists as '%qm', t(setr(f, create(%0, ))), #-1 Error when creating faction '%0', strcat(parent(%qf, v(d.faction_parent)), strmatch(parent(%qf), v(d.faction_parent))), #-1 Error when setting faction parent. Please type: @parent %qf=[v(d.faction_parent)], %qf))


--------------------------------------------------------------------------------
-- ACTION: Details About a Faction (faction) -----------------------------------

	faction(details, <faction>[, <player dbref>])

f: faction dbref
p: player dbref, if passed

note: | is a protected symbol here, but we'll keep things that could use it
	  at the end of the returned information

--

&action.details Faction Groups=
localize(
	case(0, 

@@ .. faction checks
		t(setr(f, u(action.factions, %0))), 
		#-1 Faction '%0' not found, 

		eq(words(%qf), 1), 
		#-1 Too many matching factions found, 

@@ .. faction details (no player dbref passed): 
@@ .. <dbref>|<member dbrefs>|<permissions>|<desc>
		strlen(%1), 
		%qf|
		[iter()]|
		[get(%qf/permissions.view)]|
		[get(%qf/desc)]|, 

@@ .. player checks 
		t(setr(p, pmatch(%qp))), 
		#-1 Player '%1' has too many matches or not found, 

		t(get(%qf/member.power.%qd)), 
		#-1 Player '[name(%qd)]' not a member of faction '[name(%qf)]', 

@@ .. player details
@@ .. <dbref>|<power>|<rank>|<title>
@@ .. (<rank> and <title> may be determined via code on faction or parent)
		%qa|
		[get(%qf/member.power.%qa)]|
		[udefault(%qf/member.rank.%qa, u(%qf/default.rank, %qa))]|
		[udefault(%qf/member.title.%qa, u(%qf/default.title, %qa))]
	)
)

--

&action.details Faction Groups=localize(case(0, t(setr(f, u(action.factions, %0))), #-1 Faction '%0' not found, eq(words(%qf), 1), #-1 Too many matching factions found, strlen(%1), %qf|[iter()]|[get(%qf/permissions.view)]|[get(%qf/desc)]|, t(setr(p, pmatch(%qp))), #-1 Player '%1' has too many matches or not found, t(get(%qf/member.power.%qd)), #-1 Player '[name(%qd)]' not a member of faction '[name(%qf)]', %qa|[get(%qf/member.power.%qa)]|[udefault(%qf/member.rank.%qa, u(%qf/default.rank, %qa))]|[udefault(%qf/member.title.%qa, u(%qf/default.title, %qa))]))


--------------------------------------------------------------------------------
-- ACTION: Add Player to Faction (individual) ----------------------------------

	faction(add, <player>, <faction>)

p: dbref of player to add
f: faction dbref

e: possible error from functions: set()

--

&action.add Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(_isstaff, %#), 
		#-1 Staff only, 

		t(setr(p, pmatch(%0))), 
		#-1 Player '%0' not found, 

		t(u(_isapproved, %qp)), 
		#-1 Player is not approved for RP, 

		t(setr(f, u(action.factions, %1))), 
		#-1 Faction '%1' not found, 

		eq(words(%qf), 1), 
		#-1 Multiple faction matches, 

		hasattr(%qf, member.power.%qp), 
		#-1 '[name(%qp)]' is already member of faction '[name(%qf)]', 

@@ power check here
@@ 		xxx

		eq(strlen(setr(e, set(%qf, member.power.%qp:<<< power lvl >>>))), 0), 
		#-1 %qe, 

@@ OK
		1
	)
)

--

&action.add Faction Groups=localize(case(0, u(_isstaff, %#), #-1 Staff only, t(setr(p, pmatch(%0))), #-1 Player '%0' not found, t(u(_isapproved, %qp)), #-1 Player is not approved for RP, t(setr(f, u(action.factions, %1))), #-1 Faction '%1' not found, eq(words(%qf), 1), #-1 Multiple faction matches, hasattr(%qf, member.power.%qp), #-1 '[name(%qp)]' is already member of faction '[name(%qf)]', eq(strlen(setr(e, set(%qf, member.power.%qp:<<< power lvl >>>))), 0), #-1 %qe, 1))


--------------------------------------------------------------------------------
-- ACTION: Change Member's Power Level on Faction (individual) -----------------





================================================================================
== COMMAND SUPPORT =============================================================

--------------------------------------------------------------------------------
-- FILTER: Valid Factions ------------------------------------------------------

Filters a list of dbrefs and returns those that meet the 'valid faction' criteria, for a bit of security.

Sample Usage: filter(fil.valid_factions, lcon(%!))

--

&fil.valid_factions Faction Groups=and(strmatch(loc(%0), %!), strmatch(parent(%0), v(d.faction_parent)))


--------------------------------------------------------------------------------
-- FILTER: Cansee Factions -----------------------------------------------------

Filters a list of dbrefs (should be checked as 'valid factions') to only the ones that a player can see.

Sample Usage: 
	filter(fil.cansee_factions, filter(fil.valid_factions, lcon(%!)), , , %#)

--

&fil.cansee_factions Faction Groups=1


--------------------------------------------------------------------------------
-- FILTER: Faction Name Filter -------------------------------------------------

Filters a list of dbrefs (should be checked as 'valid factions') to only the ones that a player can see.

Sample Usage: 
	filter(fil.factions_byname, filter(fil.valid_factions, lcon(%!)), , , *est*)

--

&fil.factions_byname Faction Groups=strmatch(name(%0), %1*)


