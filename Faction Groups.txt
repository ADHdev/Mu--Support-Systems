================================================================================
== PLANNING ====================================================================


--------------------------------------------------------------------------------
-- PLANNING: Outline -----------------------------------------------------------

FACTIONS REWRITE FROM COMPLETE AND TOTAL SCRATCH

The purpose of this project is to replace the tried-and-true, but much-aged Aether Factions system (originally written for TinyMUSH 3.2).

This may be a mid-step between an all-Mu* setup and an SQL system.

Actions apply <faction> to <player>
	+faction/add <player>=<faction>
	+faction/title <player>/<faction>=<title>


--------------------------------------------------------------------------------
-- PLANNING: API ---------------------------------------------------------------

A usable function-based API is a must.  I'll be doing my favorite method:
	faction(<action>, <input>)

e.g.: faction(factions[, <partial faction name>])
      faction(list, <faction name>)
      faction(details, <faction name>[, <player name>])
      faction(add, <player name>, <faction name>)


--------------------------------------------------------------------------------
-- PLANNING: Cross-Platform ----------------------------------------------------

All user-defined or cross-platform function issues should (should, mind you) go in their own function class.

	&.<function name>


-- TEMPORARY NOTES -------------------------------------------------------------

Coventry says:
	trim( squish( iter( %0, if( strmatch( %i0, %1 ), %i0 ), %2, %2 ), %2 ), %2 )

... as a filter for matching dbref to name.  
(will need: strmatch( name( %i0 ), %1)

Use with list/who


--------------------------------------------------------------------------------
-- PLANNING: Actions & Queries -------------------------------------------------

NOTE TO SELF: Can add factions to another faction
	- Loop-check
	- Permissions inherit?  Override?

Lists return dbrefs unless mentioned otherwise.
Items in (parenthesis) are the defaults for that command.

System Actions/Queries - 
	global: <item(s)>
		Return the value of a global default setting(s).
		- in these 'get' cases, return |-delim list of values. e.g.:
		- faction(globals, active title) -> 64|<null>
	global: <item>, <value>
		Set a default setting.  If null, erase.
		- active: Days until a player is considered inactive (default: 30)
		- power: The default member power level (default: member)
		- rank: The default member numeric rank (default: null)
		- title: The default member title (default: null)
		- category: The default faction category (default: null)
	powers: [<name filter>]
		List (all) possible access level powers

Faction Actions/Queries - 
	activate: <faction>
		Create/re-activate a faction.
	deactivate: <faction>
		Make a faction inactive.
	default: <faction>, <item(s)> | <faction>, <item>, <value>
		Change the default for this faction. See 'global', above.
		- description: A decription of the faction
		- permission.view (???): A permission on who's allowed to see the faction.
	roster: <faction>[, active|inactive|all]
		List all (default: active) faction members.
	who: <faction>[, active|inactive|all]
		List connected (active) faction members.
		(add 'isfaction()' for backwards compatability)
	mail: <faction>, <title>[, active|inactive|all]
		Starts a @mail to all (active) faction members.
	clean: <faction>
		Force an "allowed to RP" check for members of, and the faction itself.

Member Actions/Queries - 
√	add: <member>, <faction>
		Add member to a faction. (Faction may be inactive.)
		@mail player if they can see the faction (e.g., not double-blind).
	delete: <member>, <faction>
		Completely remove a member from a faction. (Faction may be inactive.)
√	mget: <member>, <faction>, <item|list>
		Return the value(s) of a faction member's setting
√	mset: <member>, <faction>, <item>[, <value>]
		Set a faction member's setting.  If null, set to null/default
		- power: Numeric power level of a member: Null -> default
		- rank: The numeric rank
		- title: The title
	memberof: <member>[, active|inactive|all]
		List all (active) factions a member is a part of.


--------------------------------------------------------------------------------
-- PLANNING: Access Privs ------------------------------------------------------

Options:
	faction:<faction> - is in
	attribute:<attr> - has
	attribute:<attr>:<value> - has at value
	stat:<stat> - has
	stat:<stat>:<value> - stat is >= <value>
	stat:<stat>::<string> - has stat (substat)
	flag:<flag> - has
	template:<template> - is
	sphere:<sphere> - is in
	location:<location> - is in

Usage:
	<access>|<access>|<access>

e.g.:
	attribute:sees_spirits|faction:spirit

Uses the Access System Fob (#3233 on The Reach).  General usage is applying the player to the access rules.  Multiple rules are 'or', returns true if any are true.

	
--------------------------------------------------------------------------------
-- PLANNING: Data Dictionary ---------------------------------------------------

* Faction Parent
(global defaults)

&member.active
	Days until a player is considered 'inactive'.  This is different than a 
	frozen player, who is always inactive.  A frozen player is determined by the 
	game.  The default default is '30'.

&member.power
	The default power level for new members.  The default is 'member'.

&member.rank
	The default numeric rank for new members.  The default is <null>.

&member.title
	The default title for new members.  The default is <null>.

&faction.active
	Is faction active?  Default '1'.  If other, note on the Faction Object

&faction.category
	The faction's main category (for listing)

&faction.permission.<type>
	Permission of type <type>
	- view: Who can see this faction. If 'faction:!<faction name>', nobody can

&d.powers
	A list of valid member power levels
	- member: Nothing special, normal member
	- view: Member who can view faction even with double-blind
	- admin: View rights plus can edit, add & remove members, staff are admin

--

* Faction Object

All the defaults (&faction./&member.) can be altered for a faction.

@name
	Name of the faction

@description
	Base information about the faction

Parented items (may be changed per-faction):
	member.active, member.power, member.rank, member.title, faction.active, 
	faction.category, faction.permission.<type>

--

* Member Info (on Faction Object)

&member.power.<dbref>
	Power/responsibility level (admin/member)
	Must not be null; its existence says <dbref> is faction member

&member.title.<dbref>
	Faction title for <dbref>. Max length: 30 characters. If title is null, use faction default in display.

&member.rank.<dbref>
	Faction rank of <dbref>. Numeric, -999 to 999, determines faction's primary sort order. If rank is null, use faction default in display.

&member.title.default
	Allows a default (formula) for title

&member.rank.default
	Allows a default (formula) for rank

--

The system will determine if to use title/rank defaults thus:

	udefault(<faction>/member.<element>.<dbref>, 
		u(<faction>/member.<element>, <dbref>)
	)

e.g.
	udefault(#xxx/member.title.#yyy, u(#xxx/member.title, #yyy))

This will allow formulae in the title and rank to grab player information, if necessary.

--

Faction defaults will happen naturally, as the @parenting will read higher up.


================================================================================
== FACTIONS ====================================================================

@create Faction Groups <fg>=10
@desc Faction Groups=A system to list people by their affiliation(s)

@set Faction Groups=inherit
@set Faction Groups=safe

@parent Faction Groups=codp
&prefix.cross_platform Faction Groups=.
&prefix.user_function_actions Faction Groups=action.

&d.one-day Faction Groups=86400

--

@create Faction Parent=10
@desc Faction Parent=Please replace this with basic information about the faction!
@fo me=&d.faction_parent Faction Groups=[num(Faction Parent)]

@parent Faction Parent=codp

@@ >> global functions -- null defaults are reminders that they exist

&member.active Faction Parent=30
&member.power Faction Parent=member
&member.rank Faction Parent=
&member.title Faction Parent=
&faction.permission.view Faction Parent=
&faction.active Faction Parent=1

&d.powers Faction Parent=member|view|admin

@tel Faction Parent=Faction Groups


--------------------------------------------------------------------------------
-- FUNCTION: Cross-Platform Functions ------------------------------------------

&.header Faction Groups=wheader(%0)
&.footer Faction Groups=wfooter(%0)
&.divider Faction Groups=wdivider(%0)

&.msg Faction Groups=msg(h, %0, %1)

&.isstaff Faction Groups=isstaff(%0)

&.isapproved Faction Groups=isapproved(%0)

&.crumple Faction Groups=trim(squish(%0))


================================================================================
== COMMAND SETUP ===============================================================

The "Mistress System" funnels everything through a single command.  For this command, like many others, an optional 's' on it is valid.  e.g., faction/factions.

	+command(s) -> &c.<command>.default
	+command(s) <stuff> -> &c.<command>.specific
	+command(s)/switches [<stuff>] -> &c.<command>/<switch>

To each of these (including the first), the following are passed:
	%0: <stuff>
	%1: </other/switches>

In the case of the switches, the first valid switch has their command called, if all switches are invalid we call &c.<name>.default or &c.<name>.specific, depending on the above rules.

--

&c.factions Faction Groups=$faction*:@pemit %#=
	[setq(n, factions)]
	[switch(%0, 
@@ Without 's' ending
		, u(c.%qn.default), 
		/*, u(c.%qn.switch, first(%0), rest(%0)), 
		%b*, u(c.%qn.specific, trim(%0)), 

@@ With 's' ending
		s, u(c.%qn.default), 
		s/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), 
		s%b*, u(c.%qn.specific, trim(rest(%0))), 

@@ No match
		Error: I don't know what you mean. Please see [ansi(h, +help %qn)]
	)]

--

&c.factions Faction Groups=$faction*:@pemit %#=[setq(n, factions)][switch(%0, , u(c.%qn.default), /*, u(c.%qn.switch, first(%0), rest(%0)), %b*, u(c.%qn.specific, trim(%0)), s, u(c.%qn.default), s/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), s%b*, u(c.%qn.specific, trim(rest(%0))), Error: I don't know what you mean. Please see [ansi(h, +help %qn)])]



--------------------------------------------------------------------------------
-- factions/<switch> -----------------------------------------------------------

Handles all /switches, which is to say it makes sure they exist and passes them on.

Also handles pseudo-switches, passing them on as elements to any switched item.

Passes to &c.<name>.specific (%1, %qp) or &c.<name>/<switch> (%1, %qp), even if %1 is empty.

--

0: /<switch>[/<switch>/<switch>, etc.]
1: [<more>], stuff to pass to c.<name>/<switch>, if any
qn: Name of the command, global register set in &c.<name> (above)

qa: all c.<name>/* on this object
qs: /valid/command/switches/found
qp: /pseudo/switches/found, pass to c.<name>[/<switch>]

--

&c.factions.switch Faction Groups=
	[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))]
	[iter(rest(%0, /), 
		if(
			t(grab(%qa, c.%qn/%i0*)), 
			setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), 
			setq(p, %qp/%i0)
		), 
		/, @@
	)]
	[if(t(%qs), 
		ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), 
		if(t(%1), 
			ulocal(c.%qn.specific, %1, %qp), 
			ulocal(c.%qn.default, %1, %qp)
		)
	)]

--

&c.factions.switch Faction Groups=[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))][iter(rest(%0, /), if(t(grab(%qa, c.%qn/%i0*)), setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), setq(p, %qp/%i0)), /, @@)][if(t(%qs), ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), if(t(%1), ulocal(c.%qn.specific, %1, %qp), ulocal(c.%qn.default, %1, %qp)))]


--------------------------------------------------------------------------------
-- factions (default) ----------------------------------------------------------

Show default factions setup: List factions

--

0: passed by fake /switches, ignored
1: fake /switches, error

--

&c.factions.default Faction Groups=if(strlen(%1), u(.msg, factions, Factions doesn't take that switch. See +help factions), u(c.factions/default))


--------------------------------------------------------------------------------
-- factions <stuff> (specific) -------------------------------------------------

Show information about a particular faction

--

0: faction name or dbref
1: fake /switches, errored

--

&c.factions.specific Faction Groups=if(strlen(%1), u(.msg, factions, Factions doesn't take that switch. See +help factions), u(c.factions/faction))


--------------------------------------------------------------------------------
-- factions/list ---------------------------------------------------------------

&c.factions/list Faction Groups=Factions/List


--------------------------------------------------------------------------------
-- factions/faction ------------------------------------------------------------

&c.factions/faction Faction Groups=Factions/faction


================================================================================
== ACTIONS =====================================================================

<see planning, above, for the actions/queries list>


--------------------------------------------------------------------------------
-- ACTION: Factions List (system) ----------------------------------------------

List factions as appropriate for a certain player, which means throwing it through one or more filters.

	faction(factions[, <faction name>])

--

&action.factions Faction Groups=
	filter(fil.factions_byname, 
		filter(fil.cansee_factions, 
			filter(fil.valid_factions, lcon(%!)), 
			@@(empty idelim), @@(empty odelim), 
			%#
		), 
		@@(empty idelim), @@(empty odelim), 
		%0
	)

--

&action.factions Faction Groups=filter(fil.factions_byname, filter(fil.cansee_factions, filter(fil.valid_factions, lcon(%!)), @@(empty idelim), @@(empty odelim), %#), @@(empty idelim), @@(empty odelim), %0)

--

think u(fg/action.factions)


--------------------------------------------------------------------------------
-- ACTION: Create Faction (system) ---------------------------------------------

	faction(create, <faction name>)

f: faction dbref
m: exsting faction that matches on first 5 characters as %0

Returns: #-1 <error> or dbref.

--

&action.create Faction Groups=
localize(
	case(0, 

@@ .. staff only
		t(u(.isstaff, %@)), 
		#-1 Staff only, 

@@ .. check for valid faction object name
		valid(name, %0), 
		#-1 That's a bad name for a faction, 

@@ .. check for existing close-enough faction name (first 5 character match)
		not(setr(m, 
			grab(
				iter(filter(fil.valid_factions, lcon(%!)), name(%i0), , |), 
				[strtrunc(%0, 5)]*, 
				|
			)
		)), 
		#-1 A similar faction name already exists as '%qm', 

@@ .. check created alright
		t(setr(f, create(%0, ))), 
		#-1 Error when creating faction '%0', 

@@ .. check parented alright
		strcat(parent(%qf, v(d.faction_parent)), strmatch(parent(%qf), v(d.faction_parent))), 
		#-1 Error when setting faction parent. 
		Please type: @parent %qf=[v(d.faction_parent)], 

@@ .. ok: return object dbref
		%qf
	)
)

--

think u(fg/action.create, Test Fallacy)


--------------------------------------------------------------------------------
-- ACTION: Details About a Faction (faction) -----------------------------------

	faction(details, <faction>[, <player dbref>])

f: faction dbref
p: player dbref, if passed

note: | is a protected symbol here, but we'll keep things that could use it
	  at the end of the returned information

--

&action.details Faction Groups=
localize(
	case(0, 

@@ .. faction checks
		t(setr(f, u(action.factions, %0))), 
		#-1 Faction '%0' not found, 

		eq(words(%qf), 1), 
		#-1 Too many matching factions found, 

@@ >> faction details (no player dbref passed): 
@@ .. <dbref>|<member dbrefs>|<permissions>|<desc>
		strlen(%1), 
		%qf|
		[iter(lattr(%qf/member.power.*), last(%i0, .))]|
		[get(%qf/permissions.view)]|
		[get(%qf/desc)]|, 

@@ .. player checks 
		t(setr(p, pmatch(%1))), 
		#-1 Player '%1' has too many matches or not found, 

		t(get(%qf/member.power.%qp)), 
		#-1 Player '[name(%qp)]' not a member of faction '[name(%qf)]', 

@@ >> player details
@@ .. <dbref>|<power>|<rank>|<title>
@@ .. (<rank> and <title> may be determined via code on faction or parent)
		%qp|
		[get(%qf/member.power.%qp)]|
		[udefault(%qf/member.rank.%qp, u(%qf/default.rank, %qp))]|
		[udefault(%qf/member.title.%qp, u(%qf/default.title, %qp))]
	)
)

--

think u(fg/action.details, test fac)


--------------------------------------------------------------------------------
-- ACTION: Add Player to Faction (individual) ----------------------------------

	faction(add, <player>, <faction>)

p: dbref of player to add
f: faction dbref

e: possible error from functions: set()

--

&action.add Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.isstaff, %@), 
		#-1 Staff only, 

		t(setr(p, pmatch(%0))), 
		#-1 Player '%0' not found, 

		t(u(.isapproved, %qp)), 
		#-1 Player is not approved for RP, 

		t(setr(f, u(action.factions, %1))), 
		#-1 Faction '%1' not found, 

		eq(words(%qf), 1), 
		#-1 Multiple faction matches, 

		not(hasattr(%qf, member.power.%qp)), 
		#-1 '[name(%qp)]' is already member of faction '[name(%qf)]', 

@@ power check here
@@ 		xxx

		eq(strlen(setr(e, set(%qf, member.power.%qp:<<< power lvl >>>))), 0), 
		#-1 %qe, 

@@ OK
		1
	)
)

--

&action.add Faction Groups=localize(case(0, u(.isstaff, %@), #-1 Staff only, t(setr(p, pmatch(%0))), #-1 Player '%0' not found, t(u(.isapproved, %qp)), #-1 Player is not approved for RP, t(setr(f, u(action.factions, %1))), #-1 Faction '%1' not found, eq(words(%qf), 1), #-1 Multiple faction matches, not(hasattr(%qf, member.power.%qp)), #-1 '[name(%qp)]' is already member of faction '[name(%qf)]', eq(strlen(setr(e, set(%qf, member.power.%qp:<<< power lvl >>>))), 0), #-1 %qe, 1))

--

think u(fg/action.add, *thenomain, test)


--------------------------------------------------------------------------------
-- ACTION: Change Member's Power Level on Faction (individual) -----------------

@@ TO BE CODED


--------------------------------------------------------------------------------
-- ACTION: Member Info: Set ----------------------------------------------------

	faction(mset, <player>, <faction>, <element>[, <entry>])

p: dbref of player to add
f: faction dbref

If <entry> is null, use faction default in display.

If <player> is null, display valid <elements|>

--

&action.mset Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.isstaff, %@), 
		#-1 Staff only, 

@@ .. (if <player> is empty, show valid <elements|>)
		gt(strlen(%1), 0), 
		lcstr(edit(sort(lattr(%!/f.mset.*), , , |), F.MSET., , _, %b)), 

		t(setr(f, u(action.factions, %1))), 
		#-1 Faction '%1' not found, 

		eq(words(%qf), 1), 
		#-1 Multiple faction matches, 
		
		t(setr(p, pmatch(%0))), 
		#-1 '%0' is not a valid player name, 

		hasattr(%qf, member.power.%qp), 
		#-1 '[name(%qp)]' is not a member of faction '[name(%qf)]', 

		t(setr(a, lattr(%!/f.mset.%2*))), 
		#-1 Mset for '%2' not found, 

		eq(words(%qa), 1), 
		#-1 Multiple set-item matches, 

@@ .. ok to set
		u(%qa, %qp, %qf, %3)
	)
)

--

think u(fg/action.mset, *thenomain, test, title, \[title\])
think u([first(u(fg/action.details, test), |)]/member.title.[pmatch(thenomain)])

think u(fg/action.mset, *thenomain, test, rank, \[title\])
think u(fg/action.mset, *thenomain, test, rank, 1500)

think u(fg/action.mset, *thenomain, test, rank, 15)
think u([first(u(fg/action.details, test), |)]/member.rank.[pmatch(thenomain)])

think u(fg/action.mset, *thenomain, test, power, 15)

think u(fg/action.mset, *thenomain, test, power, ad)
think u([first(u(fg/action.details, test), |)]/member.power.[pmatch(thenomain)])


--------------------------------------------------------------------------------
-- ACTION: Member Info: Get ----------------------------------------------------

	faction(mset, <player>, <faction>, <item|list>)

p: player dbref
f: faction dbref

If <entry> is null, use faction default in display.

If <player> is null, display valid <items|>

--

&action.mget Faction Groups=
localize(
	case(0, 
@@ .. basic checks
		u(.isstaff, %@), 
		#-1 Staff only, 

@@ .. (if <player> is empty, show valid <elements|>)
		gt(strlen(%1), 0), 
		lcstr(edit(sort(lattr(%!/f.mget.*), , , |), F.MGET., , _, %b)), 

		t(setr(f, u(action.factions, %1))), 
		#-1 Faction '%1' not found, 

		eq(words(%qf), 1), 
		#-1 Multiple faction matches, 
		
		t(setr(p, pmatch(%0))), 
		#-1 '%0' is not a valid player name, 

		hasattr(%qf, member.power.%qp), 
		#-1 '[name(%qp)]' is not a member of faction '[name(%qf)]', 

@@ .. ok to get
		iter(%2, 
			udefault(
				first(sort(lattr(%!/f.mget.%i0*))), 
				#-1 %i0, 
				%qp, %qf, 
			), 
			|, |
		)
	)
)

--

think 

think u(fg/action.mget, *thenomain, test, title)
think u(fg/action.mget, *thenomain, test, rank)
think u(fg/action.mget, *thenomain, test, power)

think u(fg/action.mget, *thenomain, test, u(fg/action.mget))

think u(fg/action.mget, *thenomain, test, title|flange|power)



--------------------------------------------------------------------------------
-- ACTION: Faction Roster ------------------------------------------------------




================================================================================
== FILTERS =====================================================================


--------------------------------------------------------------------------------
-- FILTER: Valid Factions ------------------------------------------------------

Filters a list of dbrefs and returns those that meet the 'valid faction' criteria, for a bit of security.

Sample Usage: filter(fil.valid_factions, lcon(%!))

--

&fil.valid_factions Faction Groups=and(strmatch(loc(%0), %!), strmatch(parent(%0), v(d.faction_parent)))


--------------------------------------------------------------------------------
-- FILTER: Cansee Factions -----------------------------------------------------

Filters a list of dbrefs (should be checked as 'valid factions') to only the ones that a player can see.

Sample Usage: 
	filter(fil.cansee_factions, filter(fil.valid_factions, lcon(%!)), , , %#)

--

&fil.cansee_factions Faction Groups=1


--------------------------------------------------------------------------------
-- FILTER: Faction Name Filter -------------------------------------------------

Filters a list of dbrefs (should be checked as 'valid factions') to only the ones that a player can see.

Sample Usage: 
	filter(fil.factions_byname, filter(fil.valid_factions, lcon(%!)), , , *est*)

--

&fil.factions_byname Faction Groups=strmatch(name(%0), %1*)


--------------------------------------------------------------------------------
-- FILTER: Active Players in Faction -------------------------------------------

	u(f.player-is-active, <player dbref>, <faction dbref>)
	filter(f.player-is-active, <player list>, , , <faction dbref>)

0: list of player dbrefs
1: faction dbref (for pulling its 'active' default)

--

&fil.active_players Faction Groups=
	lte(
		if(hasflag(%0, CONNECT), 
			idle(%0), 
			sub(secs(), convtime(get(%0/last)))
		), 
		mul(get(%1/member.active), v(d.one-day))
	)

--

think u(fg/fil.active_players, pmatch(thenomain), u(fg/action.factions, test))

think filter(fg/fil.active_players, <roster>, , , u(fg/action.factions, test))

think setdiff(<roster>, filter(fg/fil.active_players, <roster>, , , u(fg/action.factions, test)))



================================================================================
== INTERNAL FUNCTIONS ==========================================================


--------------------------------------------------------------------------------
-- FUNCTION: List Categories ---------------------------------------------------

List the categories from all (passed) faction dbrefs - not validated

0: Faction dbref list (optional)

--

&f.categories.list Faction Groups=
	setunion(
		iter(
			if(strlen(%0), 
				filter(fil.valid_factions, %0), 
				filter(fil.valid_factions, lcon(%!))
			), get(%i0/faction.category), 
			@@(null), 
			|
		), 
		@@(null), 
		|
	)

--

think u(fg/f.categories.list)
think u(fg/f.categories.list, #7673)


--------------------------------------------------------------------------------
-- FUNCTION: Member Set: Title -------------------------------------------------

0: member dbref
1: faction dbref
2: title value

&f.mset.title Faction Groups=
localize(
	case(0, 

		lte(strlen(%2), 30), 
		#-1 Title may be at most 30 characters, 

		eq(strlen(setr(e, set(%1, member.title.%0:[escape(%2)]))), 0), 
		#-1 %qe, 

@@ OK
		1
	)
)


--------------------------------------------------------------------------------
-- FUNCTION: Member Set: Rank --------------------------------------------------

0: member dbref
1: faction dbref
2: rank value

--

&f.mset.rank Faction Groups=
localize(
	case(0, 

		or(isint(%2), not(comp(, %2))), 
		#-1 Rank must be numeric or blank to clear, 

		and(gte(%2, -999), lte(%2, 999)), 
		#-1 Rank must be between -999 and 999 or blank to clear, 

		eq(strlen(setr(e, set(%1, member.rank.%0:%2))), 0), 
		#-1 %qe, 

@@ OK
		1
	)
)


--------------------------------------------------------------------------------
-- FUNCTION: Member Set: Power -------------------------------------------------

0: member dbref
1: faction dbref
2: power value ('power' must always be set!)

--

&f.mset.power Faction Groups=
localize(
	case(0, 

@@ if <power value> is null, explicitly set
		comp(, %2), 
		if(
			neq(strlen(setr(e, set(%1, 
				member.power.%0:[get(%1/member.power)]
			))), 0), 
			#-1 %qe, 
			1
		), 

		t(setr(p, grab(|[get(v(d.faction_parent)/d.powers)], %2*, |))), 
		#-1 Power type not found, 

		eq(strlen(setr(e, set(%1, member.power.%0:%qp))), 0), 
		#-1 %qe, 

@@ OK
		1
	)
)


--------------------------------------------------------------------------------
-- FUNCTION: Member Get: Title -------------------------------------------------

Read default if null

0: member dbref
1: faction dbref

--

&f.mget.title Faction Groups=ulocal(%1/member.title.%0, u(%1/member.title, %0))


--------------------------------------------------------------------------------
-- FUNCTION: Member Get: Rank --------------------------------------------------

0: member dbref
1: faction dbref

--

&f.mget.rank Faction Groups=udefault(%1/member.rank.%0, u(%1/member.rank, %0))


--------------------------------------------------------------------------------
-- FUNCTION: Member Get: Power -------------------------------------------------

0: member dbref
1: faction dbref

--

&f.mget.power Faction Groups=u(%1/member.power.%0)



================================================================================
== DISPLAYS ====================================================================

