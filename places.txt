================================================================================
== PLANNING: Setting Up Places =================================================

The owner of a location should be able to set up places there, but the concept of "owner" is sometimes an iffy one.  Some games prefer that staff own all public hangouts, for example, even though a noncharbit has administrative control over it.

We'll store everything, including this optional 'places owner' lock, on a set of room attributes prefixed &places.* & keep controlled information locked to the places object.

	places.<num>.details: <name>|<spaces>|<description>
	places.<num>.notices: 
		<say prefix>|<join>|<ojoin>|<depart>|<odepart>
	places.<num>.occupancy: <who's there>

(If 'spaces' is 0, no limit.)

If we get this far, lock to the places system object:

	places.administrators: <list of people who can set up places here>

User-defined commands we'll need:

	isstaff(<player>) - return '1' if player has staff access
	lmin(<list> [, <delimiter>]) - min() with delimiter

	header(<text>) - game's default command header
	footer(<text>) - game's default command footer
	divider() - minor divider
	wheader(), wdivider(), wfooter() - A width()-friendly version of the above

	alert(<test>) - prefix for informational alerts, used on &f.alert
	msg(<ansi>, <text>) - prefix for command notice, used on &f.notify
	plural(<num>, <singular text>, <plural text>) - does what it looks like
	titlestr(<string>) - Display text as something like book-title appropriate
	crumple(<string> [, <delim>]) - trim() + squish()


--------------------------------------------------------------------------------
-- Validations -----------------------------------------------------------------

The : and | characters are restricted as common output delimiters, and could mess up attribute setting.


--------------------------------------------------------------------------------
-- TO DO -----------------------------------------------------------------------

*** As-Needed Places (LA's Gatherings) ***

You could, essentially, 'go stand next to' someone and it'd make the place spontaneously and other people could join it.

And it ceases to be when all are gone.

Same, but &gathering.* (?) -- no, because the rest of the places system needs to be able to interface with it.

Instead: &place.<# of places + 1> and 
		 &_gatherings: <list of place numbers that are gatherings>


*** Evesdropping Staff ***

Extend '*.occupancy' to <at place>|<evesdropping> so 'tt' triggers for them, but join/leave does not.  Be loud about evesdropping.  Staff-only.


================================================================================
== SETUP: Places ===============================================================

@create Places Global Object <pgo>
@set pgo=Inherit
@set pgo=Safe

@parent pgo=Code Object Data Parent <codp>
&prefix.user_function_actions pgo=action.


--------------------------------------------------------------------------------
-- @adisconnect ----------------------------------------------------------------

Because TinyMUX and PennMUSH, as of this writing, don't have rooms checking @adisconnect for their contents, allowing only zones to do this, we're forced to do some mental gymnastics.  We could override the room's @listen/@ahear, but I'd rather this clearner solution.

Using @eval so it only hits the command queue once, in unlikely fringe timing cases.

Using iter() to catch all rooms needing cleaned.  Again unlikely, but there.

-

@adisconnect pgo=@eval iter(search(eroom=grep(##, places.*.occupancy, %#)), places(depart, ##, %#))


================================================================================
== PLACES GLOBAL OBJECT <pgo> ==================================================

Commands:

	places - the main driving command
	tt[ooc] - tabletalk
	join & depart - there we go

NOTE TO SELF: I think the 'mutter' commands try to integrate with the places systems.  Remember to check and fix accordingly.


================================================================================
== DATA ========================================================================


--------------------------------------------------------------------------------
-- Element Defaults ------------------------------------------------------------

If a places element is not set, or while setting up, use these defaults.

&d.default.name pgo=a table
&d.default.spaces pgo=5
&d.default.description pgo=A table with a couple of chairs.

&d.default.say_prefix pgo=At your table,
&d.default.join pgo=joins everyone here at #NAME.
&d.default.ojoin pgo=sits at #NAME (##LOC).
&d.default.depart pgo=departs your table.
&d.default.odepart pgo=departs #NAME (##LOC).

================================================================================
== COMMAND SETUP ===============================================================

The "Mistress System" funnels everything through a single command.  For this command, like many others, an optional 's' on it is valid.  e.g., place/places.

	+command(s) -> &c.<command>.default
	+command(s) <stuff> -> &c.<command>.specific
	+command(s)/switches [<stuff>] -> &c.<command>/<switch>

To each of these (including the first), the following are passed:
	%0: <stuff>
	%1: </other/switches>

In the case of the switches, the first valid switch has their command called, if all switches are invalid we call &c.<name>.default or &c.<name>.specific, depending on the above rules.

--

&c.places Places Global Object=$place*:@pemit %#=
	[setq(n, places)]
	[switch(%0, 
@@ Without 's' ending
		, u(c.%qn.default), 
		/*, u(c.%qn.switch, first(%0), rest(%0)), 
		%b*, u(c.%qn.specific, trim(%0)), 

@@ With 's' ending
		s, u(c.%qn.default), 
		s/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), 
		s%b*, u(c.%qn.specific, trim(rest(%0))), 

@@ No match
		Error: I don't know what you mean. Please see [ansi(h, +help %qn)]
	)]

--

&c.places Places Global Object=$place*:@pemit %#=[setq(n, places)][switch(%0, , u(c.%qn.default), /*, u(c.%qn.switch, first(%0), rest(%0)), %b*, u(c.%qn.specific, trim(%0)), s, u(c.%qn.default), s/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), s%b*, u(c.%qn.specific, trim(rest(%0))), Error: I don't know what you mean. Please see [ansi(h, +help %qn)])]


--------------------------------------------------------------------------------
-- places/<switch> -------------------------------------------------------------

Handles all /switches, which is to say it makes sure they exist and passes them on.

Also handles pseudo-switches, passing them on as elements to any switched item.

Passes to &c.<name>.specific (%1, %qp) or &c.<name>/<switch> (%1, %qp), even if %1 is empty.

--

0: /<switch>[/<switch>/<switch>, etc.]
1: [<more>], stuff to pass to c.<name>/<switch>, if any
qn: Name of the command, global register set in &c.<name> (above)

qa: all c.<name>/* on this object
qs: /valid/command/switches/found
qp: /pseudo/switches/found, pass to c.<name>[/<switch>]

--

&c.places.switch Places Global Object=
	[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))]
	[iter(rest(%0, /), 
		if(
			t(grab(%qa, c.%qn/%i0*)), 
			setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), 
			setq(p, %qp/%i0)
		), 
		/, @@
	)]
	[if(t(%qs), 
		ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), 
		if(t(%1), 
			ulocal(c.%qn.specific, %1, %qp), 
			ulocal(c.%qn.default, %1, %qp)
		)
	)]

--

&c.places.switch Places Global Object=[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))][iter(rest(%0, /), if(t(grab(%qa, c.%qn/%i0*)), setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), setq(p, %qp/%i0)), /, @@)][if(t(%qs), ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), if(t(%1), ulocal(c.%qn.specific, %1, %qp), ulocal(c.%qn.default, %1, %qp)))]


--------------------------------------------------------------------------------
-- places (default) ------------------------------------------------------------

Show default places setup.

>> DO NOT WORK IF ROOM IS SET HALT <<

Because of the @aleave/@startup that's placed on a room, if it's set halt then the cleanup code won't work properly.  Annoy people to unset it.

--

0: ignored
1: fake /switches, ignored

ql: location of %#

--

&c.places.default Places Global Object=
	case(0, 
		not(hasflag(loc(%#), HALT)), 
		[u(f.alert, places)] Places cannot work while the room is set HALT., 

		attrcnt([setr(l, loc(%#))]/places.1.details), 
		[u(f.alert, places)] Places not configured., 

		list(
			lattr(%ql/places.*.details), 
			u(f.display.one-place-brief, %ql, elements(%i0, 2, .))
		)
	)

--

&c.places.default Places Global Object=case(0, not(hasflag(loc(%#), HALT)), [u(f.alert, places)] Places cannot work while the room is set HALT., attrcnt([setr(l, loc(%#))]/places.1.details), [u(f.alert, places)] Places not configured., list(lattr(%ql/places.*.details), u(f.display.one-place-brief, %ql, elements(%i0, 2, .))))


--------------------------------------------------------------------------------
-- places <stuff> (specific) ---------------------------------------------------

Show information about a particular place

>> DO NOT WORK IF ROOM IS SET HALT <<

Because of the @aleave/@startup that's placed on a room, if it's set halt then the cleanup code won't work properly.  Annoy people to unset it.

--

0: place name or number
1: fake /switches, ignored

ql: location of %#
qn: number of location, if name or #<num> passed

--

&c.places.specific Places Global Object=
	case(1, 
		hasflag(loc(%#), HALT), 
		[u(f.alert, places)] Places cannot work while the room is set HALT., 

		not(attrcnt([setr(l, loc(%#))]/places.1.details)), 
		[u(f.alert, places)] Places not configured., 

		and(
			isint(setr(n, if(strmatch(%0, #*), rest(%0, #), %0))), 
			hasattr(%ql, places.%qn.details)
		), 
		u(f.display.one-place-detailed, %ql, %qn), 
		
		and(
			t(setr(n, u(f.get-num-by-name, %ql, %0))), 
			hasattr(%ql, places.%qn.details)
		), 
		u(f.display.one-place-detailed, %ql, %qn), 

		[u(f.alert, places)] I can't find that place.
	)

--

&c.places.specific Places Global Object=case(1, hasflag(loc(%#), HALT), [u(f.alert, places)] Places cannot work while the room is set HALT., not(attrcnt([setr(l, loc(%#))]/places.1.details)), [u(f.alert, places)] Places not configured., and(isint(setr(n, if(strmatch(%0, #*), rest(%0, #), %0))), hasattr(%ql, places.%qn.details)), u(f.display.one-place-detailed, %ql, %qn), and(t(setr(n, u(f.get-num-by-name, %ql, %0))), hasattr(%ql, places.%qn.details)), u(f.display.one-place-detailed, %ql, %qn), [u(f.alert, places)] I can't find that place.)


--------------------------------------------------------------------------------
-- places/configure ------------------------------------------------------------

	places/configure <location>[/<number>][=YES]

'here' should work fine.

--

qf: places() function results
ql: location for places
qn: number of places the player wants configured (always 1)

--

&c.places/configure Places Global Object=
	case(0, 
		not(comp(rest(%0, =), YES)), 
		[u(f.alert, places/configure)] Please take note! Configuring up places 
		will overwrite the room's @startup%, @ahear and @aleave attributes.  
		If the room has places set up already%, the existing places will be 
		left but these attributes will still be overwritten.  If you are alright 
		with this%, please type: [ansi(h, places/configure [before(%0, =)]=YES)], 

		t(setr(f,
			places(configure, 
				before(before(%0, =), /), 
				YES, 
				rest(before(%0, =), /)
			)
		)), 
		[u(f.alert, places/configure)] [titlestr(rest(%qf))], 

		[u(f.notify, places/configure)] Configured!
	)

--

&c.places/configure Places Global Object=case(0, not(comp(rest(%0, =), YES)), [u(f.alert, places/configure)] Please take note! Configuring up places will overwrite the room's @startup%, @ahear and @aleave attributes.  If the room has places set up already%, the existing places will be left but these attributes will still be overwritten.  If you are alright with this%, please type: [ansi(h, places/configure [before(%0, =)]=YES)], t(setr(f, places(configure, before(before(%0, =), /), YES, rest(before(%0, =), /)))), [u(f.alert, places/configure)] [titlestr(rest(%qf))], [u(f.notify, places/configure)] Configured!)


--------------------------------------------------------------------------------
-- places/breakdown ------------------------------------------------------------

	places/breakdown <location>[=YES]

qf: places() function results

--

&c.places/breakdown Places Global Object=
	case(0, 
		not(comp(rest(%0, =), YES)), 
		[u(f.alert, places/breakdown)] Please take note! Breaking down places 
		will delete the room's @startup%, @ahear and @aleave attributes%, as well as the attributes set up to make places work.  
		If you are alright with this%, please type: 
		[ansi(h, places/breakdown <location>=YES)], 

		t(setr(f, places(breakdown, first(%0, =), YES))), 
		[u(f.alert, places/breakdown)] [titlestr(rest(%qf))], 

		REMOVED!
	)

--

&c.places/breakdown Places Global Object=case(0, not(comp(rest(%0, =), YES)), [u(f.alert, places/breakdown)] Please take note! Breaking down places will delete the room's @startup%, @ahear and @aleave attributes%, as well as the attributes set up to make places work.  If you are alright with this%, please type: [ansi(h, places/breakdown <location>=YES)], t(setr(f, places(breakdown, first(%0, =), YES))), [u(f.alert, places/breakdown)] [titlestr(rest(%qf))], REMOVED!)


--------------------------------------------------------------------------------
-- places/newplace -------------------------------------------------------------

	places/newplace [<location>][=<placenum>]

qf: places() function results

--

&c.places/newplace Places Global Object=
	case(0, 
		t(setr(f, places(newplace, if(t(trim(first(%0, =))), trim(first(%0, =)), loc(%#)), rest(%0, =)))), 
		[u(f.alert, places/newplace)] [titlestr(rest(%qf))], 

		[u(f.notify, places/newplace)] Created Place Number %qf
	)

--

&c.places/newplace Places Global Object=case(0, t(setr(f, places(newplace, if(t(trim(first(%0, =))), trim(first(%0, =)), loc(%#)), rest(%0, =)))), [u(f.alert, places/newplace)] [titlestr(rest(%qf))], [u(f.notify, places/newplace)] Created Place Number %qf)


--------------------------------------------------------------------------------
-- places/delplace -------------------------------------------------------------

	places/delplace <location>=<placenum>

Feels too short.

qf: places() function results

--

&c.places/delplace Places Global Object=
	case(0, 
		t(setr(f, places(delplace, first(%0, =), rest(%0, =)))), 
		[u(f.alert, places/delplace)] [titlestr(rest(%qf))], 

		[u(f.notify, places/delplace)] Deleted Place Number %qf
	)

--

&c.places/delplace Places Global Object=case(0, t(setr(f, places(delplace, first(%0, =), rest(%0, =)))), [u(f.alert, places/delplace)] [titlestr(rest(%qf))], [u(f.notify, places/delplace)] Deleted Place Number %qf)


--------------------------------------------------------------------------------
-- places/compress -------------------------------------------------------------

Moves the places together, filling any gaps.  Does not correlate to a places() function, so do the normal set of access & validation checks.  Staff or owner only.

	places/compress <location>

ql: location dbref
qn: new place numbers list, <old>:<new> <old>:<new> <old>:<new>
qo: output from

--

&c.places/compress Places Global Object=
	case(0, 
		or(strmatch(owner(setr(l, locate(%#, %0, ha))), %#), isstaff(%#)), 
		[u(f.alert, places/compress)] Staff or Owner Only., 

		strmatch(type(%ql), ROOM), 
		[u(f.alert, places/compress)] Room Not Found., 

		hasattr(%ql, places.1.details), 
		[u(f.alert, places/compress)] Places Not Configured., 

@@ .. set the oldkey:newkey list
		[setq(n, 
			iter(
				places(list, %ql), 
				[first(%i0, :)]:[inum()], 
				|
			)
		)]
@@ .. move those that need it
		[u(f.notify, places/compress)] Compressed.
		[crumple(iter(%qn, 
			if(neq(first(%i0, :), rest(%i0, :)), 
				[null(trigger(%!/tr.moveplace, %ql, first(%i0, :), rest(%i0, :)))]
				[first(%i0, :)]->[rest(%i0, :)]
			)
		))]
	)

--

&c.places/compress Places Global Object=case(0, or(strmatch(owner(setr(l, locate(%#, %0, ha))), %#), isstaff(%#)), [u(f.alert, places/compress)] Staff or Owner Only., strmatch(type(%ql), ROOM), [u(f.alert, places/compress)] Room Not Found., hasattr(%ql, places.1.details), [u(f.alert, places/compress)] Places Not Configured., [setq(n, iter(places(list, %ql), [first(%i0, :)]:[inum()], |))][u(f.notify, places/compress)] Compressed. [crumple(iter(%qn, if(neq(first(%i0, :), rest(%i0, :)), [null(trigger(%!/tr.moveplace, %ql, first(%i0, :), rest(%i0, :)))][first(%i0, :)]->[rest(%i0, :)])))])


--------------------------------------------------------------------------------
-- places/cleanup --------------------------------------------------------------

	places/cleanup [<location>]

--

&c.places/cleanup Places Global Object=
	case(0, 
		t(setr(f, places(cleanup, if(t(%0), %0, loc(%#))))), 
		[u(f.alert, places/cleanup)] [titlestr(rest(%qf))], 

		[u(f.notify, places/cleanup)] Cleaned.
	)

--

&c.places/cleanup Places Global Object=case(0, t(setr(f, places(cleanup, if(t(%0), %0, loc(%#))))), [u(f.alert, places/cleanup)] [titlestr(rest(%qf))], [u(f.notify, places/cleanup)] Cleaned.)


--------------------------------------------------------------------------------
-- places/set ------------------------------------------------------------------

The general command to change information about a place.

	places/set [<loc>] <placenum>/<element>=<info>

ql: location dbref
qp: placenum
qe: element - name completion please, reject 'occupancy' here
qi: info

qf: function result

--

&c.places/set Places Global Object=
	[setq(p, first(%0, /))]
	[if(isint(%qp), 
		setq(l, loc(%#)), 
		[setq(l, trim(revwords(rest(revwords(%qp)))))]
		[setq(p, trim(last(%qp)))]
	)]
	[setq(e, rest(first(%0, =), /))]
	[setq(e, last(first(lattr(%!/f.set.%qe*)), .))]
	[setq(i, rest(%0, =))]

	[case(0, 
		not(strmatch(%qe, occupancy)), 
		[u(f.alert, places/set)] Please use 'places/cleanup [first(first(%0), /)]'., 

		t(setr(f, places(set, %ql, %qp, %qe, %qi))), 
		[u(f.alert, places/set)] [rest(titlestr(%qf))], 

		[u(f.notify, places/set)] Set #%qp '[lcstr(%qe)]' to '[%qi]'.
	)]

--

&c.places/set Places Global Object=[setq(p, first(%0, /))][if(isint(%qp), setq(l, loc(%#)), [setq(l, trim(revwords(rest(revwords(%qp)))))][setq(p, trim(last(%qp)))])][setq(e, rest(first(%0, =), /))][setq(e, last(first(lattr(%!/f.set.%qe*)), .))][setq(i, rest(%0, =))][case(0, not(strmatch(%qe, occupancy)), [u(f.alert, places/set)] Please use 'places/cleanup [first(first(%0), /)]'., t(setr(f, places(set, %ql, %qp, %qe, %qi))), [u(f.alert, places/set)] [rest(titlestr(%qf))], [u(f.notify, places/set)] Set #%qp '[lcstr(%qe)]' to '[%qi]'.)]


================================================================================
== OTHER COMMANDS ==============================================================

These are the commands that alias to or don't use 'places'.


--------------------------------------------------------------------------------
-- join ------------------------------------------------------------------------

Join a place

	join [ at| with] <placenum, placename, or person>

0: matched command (ignore)
1: ' at'/' with' match
2: #<stuff>, if exists (ignore)
3: <place>|<person> match

qa: place number if 'at'
qw: place number if 'with'
qd: object dbref if 'with'
qt: register of place number (a/w/null)

qf: places() function results

--

&c.join Places Global Object=$^join( at| with)?( #?(.*))?$:
@@ >> if nothing but 'join', fail
	@assert t(%3)={@pemit %#=[u(f.alert, places)] Join where?}; 
	@assert not(places(whichplace, loc(%#), %#))={@pemit %#=[u(f.alert, places)] You're already at a place. Please 'depart' first.}; 

@@ >> guess for explicit/implicit 'at' or 'with'
	@eval case(1, 
@@ .. explicit 'at'
		strmatch(%1, %bat), 
		[setq(t, a)]
		[setq(a, if(
			isint(%3), 
			trim(%3), 
			u(f.get-num-by-name, loc(%#), %3)
		))], 

@@ .. explicit 'with'
		strmatch(%1, %bwith), 
		[setq(t, w)]
		[setq(w, u(f.get-num-by-player, loc(%#), setr(d, locate(%#, %3, nP))))], 

@@ .. implicit 'at' (join <number>)
		isint(%3), [setq(t, a)][setq(a, trim(%3))], 

@@ .. implicit 'with' (join <neighbor name>)
		t(setr(d, locate(%#, %3, nP))), 
		[setq(w, u(f.get-num-by-player, loc(%#), %qd))]
		[setq(t, w)], 

@@ .. implicit 'at' (join <place name>)
		t(setr(a, u(f.get-num-by-name, loc(%#), %3))), setq(t, a), 

@@ .. panic condition
		setq(t, )
	); 

@@ >> start actual process
	@pemit %#=
		case(0, 
			comp(%qt, ), 
			[u(f.alert, places)] I can't figure out where you want to join., 

			comp(%#, %qd), 
			[u(f.alert, places)] You can't join yourself!, 

			lte(words(r(%qt)), 1), [u(f.alert, places)] Too many matches., 

			words(r(%qt)), 
			[u(f.alert, places)] [case(%qt, a, No such place, w, Not at a place)]., 

			t(setr(f, places(join, loc(%#), r(%qt), %#))), 
			[u(f.alert, places)] [rest(titlestr(%qf))], 

			@@(If things go well places() will notify everyone)
		)


--

&c.join Places Global Object=$^join( at| with)?( #?(.*))?$:@assert t(%3)={@pemit %#=[u(f.alert, places)] Join where?}; @assert not(places(whichplace, loc(%#), %#))={@pemit %#=[u(f.alert, places)] You're already at a place. Please 'depart' first.}; @eval case(1, strmatch(%1, %bat), [setq(t, a)][setq(a, if(isint(%3), %3, u(f.get-num-by-name, loc(%#), %3)))], strmatch(%1, %bwith), [setq(t, w)][setq(w, u(f.get-num-by-player, loc(%#), setr(d, locate(%#, %3, nP))))], isint(%3), [setq(t, a)][setq(a, trim(%3))], t(setr(d, locate(%#, %3, nP))), [setq(w, u(f.get-num-by-player, loc(%#), %qd))][setq(t, w)], t(setr(a, u(f.get-num-by-name, loc(%#), %3))), setq(t, a), setq(t, )); @pemit %#=case(0, comp(%qt, ), [u(f.alert, places)] I can't figure out where you want to join., comp(%#, %qd), [u(f.alert, places)] You can't join yourself!, lte(words(r(%qt)), 1), [u(f.alert, places)] Too many matches., words(r(%qt)), [u(f.alert, places)] [case(%qt, a, No such place, w, Not at a place)]., t(setr(f, places(join, loc(%#), r(%qt), %#))), [u(f.alert, places)] [rest(titlestr(%qf))], @@(If things go well places() will notify everyone))


--

@set Places Global Object/c.join=regexp


--------------------------------------------------------------------------------
-- depart ----------------------------------------------------------------------

Leave a place

	depart

In the future: depart[ for [#]<place/player>]

qf: places() function results

--

&c.depart Places Global Object=$^depart( for #?(.*))?$:

	@assert t(places(whichplace, loc(%#), %#))={@pemit %#=[u(f.alert, places)] You're not at a place. Please 'join' first.}; 

	@pemit %#=case(0, 
		t(setr(f, places(depart, loc(%#), %#))), 
		[u(f.alert, places)] [rest(titlestr(%qf))], 

		@@(If things go well places() will notify everyone)
	)

--

&c.depart Places Global Object=$^depart( for #?(.*))?$:@assert t(places(whichplace, loc(%#), %#))={@pemit %#=[u(f.alert, places)] You're not at a place. Please 'join' first.}; @pemit %#=case(0, t(setr(f, places(depart, loc(%#), %#))), [u(f.alert, places)] [rest(titlestr(%qf))], @@(If things go well places() will notify everyone))

-- 

@set Places Global Object/c.depart=regexp


--------------------------------------------------------------------------------
-- tt: tabletalk ---------------------------------------------------------------

The basic unit of places are for conversation.

	tt[o[oc]] <say/pose/emit>

--

0: entire grab (ignore)
1: 'o' if tto[oc]
2: 'oc' if there (ignore)
3: ' <say/pose/emit>'

qn: place number person is at
qf: places() function results


--

&c.tt Places Global Object=$^tt(o(oc)?)?(.*)?$:

	@assert strlen(trim(%3))={[u(f.alert, places)] You need to 'tt <something>'.}; 

	@assert t(places(whichplace, loc(%#), %#))={@pemit %#=[u(f.alert, places)] You're not at a place. Please 'join' first.}; 

	@pemit %#=
		case(0, 
			t(setr(f, places(tt, loc(%#), %#, trim(%3), if(t(%1), ooc)))), 
			[u(f.alert, places)] [rest(titlestr(%qf))], 

			@@(If things go well places() will notify everyone)
		)

--

&c.tt Places Global Object=$^tt(o(oc)?)?(.*)?$:@assert strlen(trim(%3))={[u(f.alert, places)] You need to 'tt <something>'.}; @assert t(places(whichplace, loc(%#), %#))={@pemit %#=[u(f.alert, places)] You're not at a place. Please 'join' first.}; @pemit %#=case(0, t(setr(f, places(tt, loc(%#), %#, trim(%3), if(t(%1), ooc)))), [u(f.alert, places)] [rest(titlestr(%qf))], @@(If things go well places() will notify everyone))

--

@set Places Global Object/c.tt=regexp


================================================================================
== COMPATIBLE COMMANDS =========================================================

These are commands that are aliased from the old places system to the new, or a notice that the command no longer works.

-- 

&c.old.plook pgo=$plook*:@pemit %#=case(1, t(%0), u(c.places.specific, trim(%0)), u(c.places.default))

&c.old.sit pgo=$sit*:@if hasflag(%#, HALT)={@pemit %#=[u(f.alert, sit)] While you are set HALT please use 'join'.}, {@force %#=join%0}

&c.old.leave pgo=$leave*:@if hasflag(%#, HALT)={@pemit %#=[u(f.alert, leave)] While you are set HALT please use 'depart'.}, {@force %#=depart%0}

&c.old.stand pgo=$stand*:@if hasflag(%#, HALT)={@pemit %#=[u(f.alert, stand)] While you are set HALT please use 'depart'.}, {@force %#=depart%0}

&c.old.mv pgo=$mv from*:@pemit %#=[u(f.alert, places)] Moving vacancies for places has been depreciated.  Please ask the room owner to add more places to this location.

&c.old.update pgo=$update */*=*:@pemit %#=[u(f.alert, places)] Update has been depreciated.  Please use 'place/set'.

&c.old.configure pgo=$configure * places:@pemit %#=[u(f.alert, places)] Configure has been depreciated.  Please use 'places/configure'.

&c.old.unconfigure pgo=$unconfigure places:@pemit %#=[u(f.alert, places)] Unconfigure has been depreciated.  Please use 'places/breakdown'.


================================================================================
== FUNCTION: Get XXX ===========================================================

A bunch of functions to get specific information.  An easy way to get information for current and future coding.

	u(f.get, <loc>, <placenum>, <list|of|elements>)
	u(f.get.<element>, <loc>, <placenum>, <element>)

--

&f.get pgo=iter(%2, udefault(first(lattr(%!/f.get.%i0*)), #-1, %0, %1), |, |)

&f.get.name pgo=u(f.get-element, %0, details, %1, 1, %2, name)
&f.get.spaces pgo=u(f.get-element, %0, details, %1, 2, %2, spaces)
&f.get.description pgo=u(f.get-element, %0, details, %1, 3, %2, description)

&f.get.say_prefix pgo=elements(get(%0/places.%1.notices), 1, |)
&f.get.join pgo=u(f.get-element, %0, notices, %1, 2, %2, join)
&f.get.ojoin pgo=u(f.get-element, %0, notices, %1, 3, %2, ojoin)
&f.get.depart pgo=u(f.get-element, %0, notices, %1, 4, %2, depart)
&f.get.odepart pgo=u(f.get-element, %0, notices, %1, 5, %2, odepart)

&f.get.occupancy pgo=get(%0/places.%1.occupancy)

--

0: dbref
1: attribtue data is on
2: place num
3: location in attribute
4: name of item (for pulling default)

&f.get-element pgo=localize(
	[setq(e, elements(get(%0/places.%2.%1), %3, |))]
	[if(strlen(%qe), objeval(%0, s(%qe)), v(d.default.%4))]
)


--------------------------------------------------------------------------------
-- Function: Get Num By Name ---------------------------------------------------

Slightly related, getting the number for a particular named place is critical.  
Normally I use the name for the key, but for this system we're using the place
number.

Cheap filter().  Returns all matches, unordered - lets calling code decide what to do with it.

	u(f.get-num-by-name, <location>, <place name>)

0: room dbref
1: name

--

&f.get-num-by-name pgo=iter(lattr(%0/places.*.details), if(strmatch(first(get(%0/%i0), |), %1*), elements(%i0, 2, .)))


--------------------------------------------------------------------------------
-- Function: Get Num By Player -------------------------------------------------

Pulls the numbers of all locations a particular dbref is at.

	u(f.get-num-by-player, <location>, <player dbref>)

--

&f.get-num-by-player pgo=iter(grepi(%0, places.*.occupancy, %1), elements(%i0, 2, .))


================================================================================
== FUNCTION:= Set XXX ==========================================================

Replaces elements entirely.  No checking first; using this on a place that hasn't been set up first will cause the information to not be written, due to the nature of replace() on TinyMUX (does not create, only replaces).

	u(f.set.<element>, <loc>, <placenum>, <item>)

--

&f.set.name pgo=trigger(%!/tr.set-element, %0, details, %1, 1, %2)
&f.set.spaces pgo=trigger(%!/tr.set-element, %0, details, %1, 2, %2)
&f.set.description pgo=trigger(%!/tr.set-element, %0, details, %1, 3, %2)

&f.set.say_prefix pgo=trigger(%!/tr.set-element, %0, notices, %1, 1, %2)
&f.set.join pgo=trigger(%!/tr.set-element, %0, notices, %1, 2, %2)
&f.set.ojoin pgo=trigger(%!/tr.set-element, %0, notices, %1, 3, %2)
&f.set.depart pgo=trigger(%!/tr.set-element, %0, notices, %1, 4, %2)
&f.set.odepart pgo=trigger(%!/tr.set-element, %0, notices, %1, 5, %2)

@@ .. "occupancy" sets without a trigger to avoid timing issues w/'tt'
&f.set.occupancy pgo=[set(%0, places.%1.occupancy:%2)][trigger(%!/tr.chown, %0, places.%1.occupancy)]

--------------------------------------------------------------------------------
-- Trigger: Set Element --------------------------------------------------------

0: dbref
1: attribtue data is on
2: place num
3: location in attribute
4: new value

&tr.set-element pgo=&places.%2.%1 %0=replace(get(%0/places.%2.%1), %3, %4, |); @trigger %!/tr.chown=%0, places.%2.%1; 

&tr.set-direct pgo=&%1 %0=%2; @trigger %!/tr.chown=%0, places.%2.%1; 

================================================================================
== FUNCTION: Validate XXX ======================================================

Used primarially with &f.set.*, and should relate 1:1

	u(f.validate.<element>, <item>)

--

&f.validate.text pgo=case(1, regmatch(%0, :|%\|), No pipes or colons., and(isint(%1), gt(strlen(%0), %1)), Keep item to %1 characters)

&f.validate.num pgo=if(or(lt(%0, 0), not(isint(%0))), Positive integers only)

--

&f.validate.name pgo=u(f.validate.text, %0, 30)
&f.validate.spaces pgo=u(f.validate.num, %0)
&f.validate.description pgo=u(f.validate.text, %0)

&f.validate.say_prefix pgo=u(f.validate.text, %0, 15)
&f.validate.join pgo=u(f.validate.text, %0, 30)
&f.validate.ojoin pgo=u(f.validate.text, %0, 30)
&f.validate.depart pgo=u(f.validate.text, %0, 30)
&f.validate.odepart pgo=u(f.validate.text, %0, 30)

&f.validate.occupancy pgo=if(land(iter(%0, and(isdbref(%i0), hastype(%i0, PLAYER)), , |), |), Occupancy must be player dbrefs)


================================================================================
== DISPLAY: One Place, Brief ===================================================

Used by 'show me brief information about this place'

Uses:
	plural(<num>, <singular text>, <plural text>)

Returns:
	A Table (#1) has 1 empty place.
	  Present is: Thenomain

--

0: location dbref
1: place number

qi: information (name|spaces|occupancy)
qs: spaces (max)
qo: occupancy
qf: number of spaces free

--

&f.display.one-place-brief Places Global Object=
localize(
	[setq(i, u(f.get, %0, %1, name|spaces|occupancy))]
	[setq(s, elements(%qi, 2, |))]
	[setq(o, last(%qi, |))]

	[ansi(h, capstr(first(%qi, |)))] (#%1) has 
	[if(%qs, 
		[if(setr(f, sub(%qs, words(%qo))), %qf, no)] 
		empty [plural(%qf, place, places)], 
		no limit
	)].

	[if(words(%qo), 
		%r%b Present is: 
		[itemize(iter(%qo, name(%i0), , |), |)]
	)]
)

--

&f.display.one-place-brief Places Global Object=localize([setq(i, u(f.get, %0, %1, name|spaces|occupancy))][setq(s, elements(%qi, 2, |))][setq(o, last(%qi, |))][ansi(h, capstr(first(%qi, |)))] (#%1) has [if(%qs, [if(setr(f, sub(%qs, words(%qo))), %qf, no)] empty [plural(%qf, place, places)], no limit)].[if(words(%qo), %r%b Present is: [itemize(iter(%qo, name(%i0), , |), |)])])


================================================================================
== DISPLAY: One Place, Detailed ================================================

Used by 'show me formatted information about this place'

Returns:
	A Table (#1) has 1 empty place.
	  Present is: Thenomain

--

0: location dbref
1: place number

qi: information (name|spaces|occupancy|description)
qs: spaces (max)
qo: occupancy
qd: description
qf: number of spaces free

--

&f.display.one-place-detailed Places Global Object=
localize(
	[setq(i, u(f.get, %0, %1, name|spaces|occupancy|description))]
	[setq(s, elements(%qi, 2, |))]
	[setq(o, elements(%qi, 3, |))]
	[setq(d, elements(%qi, 4, |))]

	[wheader([titlestr(first(%qi, |))] (#%1))]%r
	%qd%r
	[wdivider()]%r
	%b This place has 
	[if(%qs, 
		[if(setr(f, sub(%qs, words(%qo))), %qf, no)] 
		empty [plural(%qf, place, places)] out of %qs, 
		no occupancy limit
	)].

	[if(t(%qo), 
		%r%b Present is: 
			[itemize(iter(%qo, name(%i0), , |), |)]
	)]%r
	
	[wfooter()]
)

--

&f.display.one-place-detailed Places Global Object=localize([setq(i, u(f.get, %0, %1, name|spaces|occupancy|description))][setq(s, elements(%qi, 2, |))][setq(o, elements(%qi, 3, |))][setq(d, elements(%qi, 4, |))][wheader([titlestr(first(%qi, |))] (#%1))]%r%qd%r[wdivider()]%r%b This place has [if(%qs, [if(setr(f, sub(%qs, words(%qo))), %qf, no)] empty [plural(%qf, place, places)] out of %qs, no occupancy limit)].[if(t(%qo), %r%b Present is: [itemize(iter(%qo, name(%i0), , |), |)])]%r[wfooter()])


================================================================================
== DISPLAY: Elements ===========================================================

The output of the various elements.


--------------------------------------------------------------------------------
-- Display Element -------------------------------------------------------------

Output any known element.  Edit any tokens in the text.

0: dbref
1: place
2: element

--

&f.display.element pgo=
	edit(
@@ .. get element - we know we'll get something if valid
		udefault(
			f.display.element.%2, 
			u(f.display.element.other, %0, %1, %2), 
			%0, %1, %2
		), 
@@ .. replace tokens
		#LOC, %1, 
		#NAME, u(f.get.name, %0, %1), 
		#LCNAME, lcstr(u(f.get.name, %0, %1))
	)

--

&f.display.element pgo=edit(udefault(f.display.element.%2, u(f.display.element.other, %0, %1, %2), %0, %1, %2), #LOC, %1, #NAME, u(f.get.name, %0, %1), #LCNAME, lcstr(u(f.get.name, %0, %1)))


--------------------------------------------------------------------------------
-- Elements to display ---------------------------------------------------------

&f.display.element.other pgo=udefault(f.get.%2, #-1 Element Unknown, %0, %1)

&f.display.element.occupancy pgo=itemize(iter(u(f.get.occupancy, %0, %1), name(%i0), , |), |)


================================================================================
== TRIGGERS ====================================================================

Almost all the triggers on the object.


--------------------------------------------------------------------------------
-- Trigger: Chown --------------------------------------------------------------

Keep Your Room Tidy.

&tr.chown pgo=@chown %0/%1=[owner(%0)]


--------------------------------------------------------------------------------
-- Trigger: Configure ----------------------------------------------------------

The room configure functions.  Since someone can run some of these multiple times, we'll unlock things that we lock first.

Setting up WILL clobber a room's @aleave, and @startup

0: Our target room.

--

&tr.configure Places Global Object=
	@unlock %0/aleave; 
	@unlock %0/startup; 

	@aleave %0=@eval places%(depart, %%!, %%#%); 
	@startup %0=@eval places%(cleanup, %%!%); 

	@chown %0/aleave=[owner(%0)]; 
	@chown %0/startup=[owner(%0)]; 

	@lock %0/aleave=%0; 
	@lock %0/startup=%0; 

--

&tr.configure Places Global Object=@unlock %0/aleave; @unlock %0/startup; @aleave %0=@eval places%(depart, %%!, %%#%); @startup %0=@eval places%(cleanup, %%!%); @chown %0/aleave=[owner(%0)]; @chown %0/startup=[owner(%0)]; @lock %0/aleave=%0; @lock %0/startup=%0; 


--------------------------------------------------------------------------------
-- Trigger: Breakdown ----------------------------------------------------------

The places removal function.

This WILL clobber a room's @aleave, and @startup

0: Our target room.

--

&tr.breakdown Places Global Object=
	@unlock %0/aleave; 
	@unlock %0/startup; 

	@aleave %0=; @startup %0=; 

	@dolist [lattr(%0/places.*)]={&## %0=}; 

--

&tr.breakdown Places Global Object=@unlock %0/aleave; @unlock %0/startup; @aleave %0=; @startup %0=; @dolist [lattr(%0/places.*)]={&## %0=}; 


--------------------------------------------------------------------------------
-- Trigger: New Place ----------------------------------------------------------

Sets up Place #%1 in room %0 with all the defaults.

--

&tr.newplace Places Global Object=
	&places.%1.details %0=[iter(name spaces description, v(d.default.%i0), , |)];
	&places.%1.notices %0=[iter(say_prefix join ojoin depart odepart, v(d.default.%i0), , |)]; 
	@chown %0/places.%1.details=[owner(%0)]; 
	@chown %0/places.%1.notices=[owner(%0)]; 

--

&tr.newplace Places Global Object=&places.%1.details %0=[iter(name spaces description, v(d.default.%i0), , |)];&places.%1.notices %0=[iter(say_prefix join ojoin depart odepart, v(d.default.%i0), , |)]; @chown %0/places.%1.details=[owner(%0)]; @chown %0/places.%1.notices=[owner(%0)]; 


--------------------------------------------------------------------------------
-- Trigger: Delete Place -------------------------------------------------------

Removes up Place #%1 in room %0.

--

&tr.delplace Places Global Object=
	&places.%1.details %0=; 
	&places.%1.notices %0=; 
	&places.%1.occupancy %0=; 

--

&tr.delplace Places Global Object=&places.%1.details %0=; &places.%1.notices %0=; &places.%1.occupancy %0=; 


--------------------------------------------------------------------------------
-- Trigger: Move Place ---------------------------------------------------------

0: room dbref
1: old placenum
2: new placenum

&tr.moveplace Places Global Object=
	@mvattr %0=places.%1.details, places.%2.details; 
	@mvattr %0=places.%1.notices, places.%2.notices; 
	@mvattr %0=places.%1.occupancy, places.%2.occupancy; 

	@chown %0/places.%2.details=[owner(%0)]; 
	@chown %0/places.%2.notices=[owner(%0)]; 
	@chown %0/places.%2.occupancy=[owner(%0)]; 

--

&tr.moveplace Places Global Object=@mvattr %0=places.%1.details, places.%2.details; @mvattr %0=places.%1.notices, places.%2.notices; @mvattr %0=places.%1.occupancy, places.%2.occupancy; @chown %0/places.%2.details=[owner(%0)]; @chown %0/places.%2.notices=[owner(%0)]; @chown %0/places.%2.occupancy=[owner(%0)]; 


================================================================================
== FUNCTIONS: Support Functions ================================================

Some functions used for various different aspects of the system.


--------------------------------------------------------------------------------
-- Configurable Display Functions ----------------------------------------------

&f.notify pgo=trim(msg(h, %0))

&f.alert pgo=alert(%0)


--------------------------------------------------------------------------------
-- Lowest Available Number -----------------------------------------------------

Passed a list of integers, it will return the lowest available positive integer.

0: list of values

&f.lowest-available-number pgo=lmin(setdiff(lnum(1, inc(lmax(%0))), %0))


================================================================================
== USER DEFINED FUNCTIONS: Support Functions ===================================

REMEMBER TO HOOK THIS INTO WHATEVER YOUR USER-DEFINED FUNCTION SETUP IS!


--------------------------------------------------------------------------------
-- places() --------------------------------------------------------------------

Rather than have one function per item, let's just have one function.

	places(<action>, <room> [, <other>])

--

&ufunc.places Places Global Object=
	[setq(l, locate(%#, %1, ahR))]
	[if(and(t(%ql), hastype(%ql, ROOM)), 
		udefault(action.%0, #-1 ACTION NOT FOUND, %ql, %2, %3, %4), 
		#-1 ROOM NOT FOUND
	)]

--

&ufunc.places Places Global Object=[setq(l, locate(%#, %1, ahR))][if(and(t(%ql), hastype(%ql, ROOM)), udefault(action.%0, #-1 ACTION NOT FOUND, %ql, %2, %3, %4), #-1 ROOM NOT FOUND)]


--------------------------------------------------------------------------------
-- places(): list --------------------------------------------------------------

List places in the room and who is at it, or list everyone in a certain place.

List is available only to the room itself, people in the room, or to a staffer.

(note: I'm using isstaff(%#), but for parent room setups it may be better to use isstaff(%@))

	places(list, <room> [, <place>])

Returns: #-1 ERROR or '<num>:<name>:<max>:<list of dbrefs>', |-delim

--

&action.list Places Global Object=
	case(0, 
		or(strmatch(%0, loc(%#)), isstaff(%#)), 
		#-1 LIST MUST BE TRIGGERED IN ROOM, 

@@ >> check that it's set up
		hasattr(%0, places.1.details), 
		#-1 PLACES NOT CONFIGURED, 

@@ >> no '<place>', return everything, may be null
		comp(%1, ), 
		sort(
			iter(lattr(%0/places.*.details), 
@@ .. less efficient than grabbing directly from attribute, more updatable 
				[setr(n, elements(%i0, 2, .))]:
				[u(f.get.name, %0, %qn, name)]:
				[u(f.get.spaces, %0, %qn, spaces)]:
				[u(f.get.occupancy, %0, %qn)], 
				, |
			), 
			n, |, |
		), 

@@ >> rudamentary '<place>' check
		hasattr(%0, places.%1.details), 
		#-1 NO SUCH PLACE, 

@@ >> 'else' assumption: place exists, so show it
		%1:
		[u(f.get.name, %0, %1, name)]:
		[u(f.get.spaces, %0, %1, spaces)]:
		[u(f.get.occupancy, %0, %1)]
	)

--

&action.list Places Global Object=case(0, or(strmatch(%0, loc(%#)), isstaff(%#)), #-1 LIST MUST BE TRIGGERED IN ROOM OR BY ROOM, hasattr(%0, places.1.details), #-1 PLACES NOT CONFIGURED, comp(%1, ), sort(iter(lattr(%0/places.*.details), [setr(n, elements(%i0, 2, .))]:[u(f.get.name, %0, %qn, name)]:[u(f.get.spaces, %0, %qn, spaces)]:[u(f.get.occupancy, %0, %qn)], , |), n, |, |), hasattr(%0, places.%1.details), #-1 NO SUCH PLACE, %1:[u(f.get.name, %0, %1, name)]:[u(f.get.spaces, %0, %1, spaces)]:[u(f.get.occupancy, %0, %1)])


--------------------------------------------------------------------------------
-- places(): cleanup -----------------------------------------------------------

Cleanup is available only to the room itself, people in the room, or to a staffer.

NOTE: Remember to scan for/clean null "gatherings" when it's installed.

	places(cleanup, <room> [, <dbrefs to remove>])

Returns: #-1 ERROR or 1 (true) if the code ran or set without error.

qp: player dbref

--

&action.cleanup Places Global Object=
	case(0, 
		or(t(%1), or(strmatch(%0, loc(%#)), isstaff(%#))), 
		#-1 CLEANUP MUST BE USED IN ROOM, 

		or(strmatch(%1, ), strmatch(setr(p, pmatch(%1)), %#), isstaff(%#)), 
		#-1 CLEANUP PLAYER MUST BE USED BY PLAYER, 

@@ no specific dbref(s), clean up everyone
		t(%qp), 
		[setq(c, lcon(%0, connect))]
		[setq(e, 
			iter(lattr(%0/places.*.occupancy), 
				set(%0, %i0:[setinter(get(%0/%i0), %qc)]), , @@
			)
		)]
		[if(comp(%qe, ), 
			#-1 [ucstr(%qe)], 
			1
		)], 

@@ specific dbref(s), clean up only them - even if they're connected
		[setq(e, 
			iter(lattr(%0/places.*.occupancy), 
				set(%0, %i0:[setdiff(get(%0/%i0), %qp)]), , @@
			)
		)]
		[if(comp(%qe, ), 
			#-1 [ucstr(%qe)], 
			1
		)]
	)

--

&action.cleanup Places Global Object=case(0, or(t(%1), or(strmatch(%0, loc(%#)), isstaff(%#))), #-1 CLEANUP MUST BE USED IN ROOM, or(strmatch(%1, ), strmatch(setr(p, pmatch(%1)), %#), isstaff(%#)), #-1 CLEANUP PLAYER MUST BE USED BY PLAYER, t(%qp), [setq(c, lcon(%0, connect))][setq(e, iter(lattr(%0/places.*.occupancy), set(%0, %i0:[setinter(get(%0/%i0), %qc)]), , @@))][if(comp(%qe, ), #-1 [ucstr(%qe)], 1)], [setq(e, iter(lattr(%0/places.*.occupancy), set(%0, %i0:[setdiff(get(%0/%i0), %qp)]), , @@))][if(comp(%qe, ), #-1 [ucstr(%qe)], 1)])


--------------------------------------------------------------------------------
-- places(): configure ---------------------------------------------------------

Configure (or re-configure) a room.  Clobbers @startup, @aleave.

Must be used by room owner or staffer.

	places(configure, <room>, YES[, <number of places>])

Returns: #-1 ERROR or 1 if it believes it was successful.

--

&action.configure Places Global Object=
	case(0, 
		or(strmatch(%#, owner(%0)), isstaff(%#)), 
		#-1 CONFIGURE MAY BE USED BY ROOM OWNER ONLY, 

		not(hasflag(%0, HALT)), 
		#-1 CONFIGURE CANNOT BE USED IF ROOM IS SET HALT, 

@@ >> validate 'number of places'
		or(
			not(strlen(%2)), 
			and(isint(%2), lte(%2, 10), gte(%2, 1))
		), 
		#-1 CONFIGURE BETWEEN 1 AND 10 PLACES, 

@@ >> 'YES' was passed, do it
		comp(%1, YES), 
		[trigger(%!/tr.configure, %0)]
		[null(iter(lnum(1, if(strlen(%2), %2, 1)), 
			if(
				not(hasattr(%0, places.%i0.details)), 
				trigger(%!/tr.newplace, %0, %i0)
			)
		))]
		1, 

@@ >> else: no 'YES', show warning
		#-1 CONFIGURE REQUIRES CONFIRMATION
	)

--

&action.configure Places Global Object=case(0, or(strmatch(%#, owner(%0)), isstaff(%#)), #-1 CONFIGURE MAY BE USED BY ROOM OWNER ONLY, not(hasflag(%0, HALT)), #-1 CONFIGURE CANNOT BE USED IF ROOM IS SET HALT, or(not(strlen(%2)), and(isint(%2), lte(%2, 10), gte(%2, 1))), #-1 CONFIGURE BETWEEN 1 AND 10 PLACES, comp(%1, YES), [trigger(%!/tr.configure, %0)][null(iter(lnum(1, if(strlen(%2), %2, 1)), if(not(hasattr(%0, places.%i0.details)), trigger(%!/tr.newplace, %0, %i0))))]1, #-1 CONFIGURE REQUIRES CONFIRMATION)


--------------------------------------------------------------------------------
-- places(): breakdown ---------------------------------------------------------

Remove places from a room permenantly. 

Clobbers @startup, @aleave.

	places(breakdown, <room> [, YES])

Returns: #-1 ERROR or 1 if it believes it was successful.

--

&action.breakdown Places Global Object=
	case(0, 
		or(strmatch(%#, owner(%0)), isstaff(%#)), 
		#-1 BREAKDOWN MAY BE USED BY ROOM OWNER ONLY, 

@@ >> 'YES' was passed, do it
		comp(%1, YES), 
		[trigger(%!/tr.breakdown, %0)]
		1, 

@@ >> else: no 'YES', show warning
		#-1 BREAKDOWN REQUIRES CONFIRMATION
	)

--

&action.breakdown Places Global Object=case(0, or(strmatch(%#, owner(%0)), isstaff(%#)), #-1 BREAKDOWN MAY BE USED BY ROOM OWNER ONLY, comp(%1, YES), [trigger(%!/tr.breakdown, %0)]1, #-1 BREAKDOWN REQUIRES CONFIRMATION)


--------------------------------------------------------------------------------
-- places(): new place ---------------------------------------------------------

Create a new place, auto-incremented and filled with defaults.

	places(newplace, <room>, [<specific place number>])

Returns: #-1 ERROR or place #, if successful.

--

&action.newplace Places Global Object=
	case(0, 
		or(strmatch(%#, owner(%0)), isstaff(%#)), 
		#-1 SET MAY BE USED BY ROOM OWNER ONLY, 

		hasattr(%0, places.1.details), 
		#-1 PLACES NOT CONFIGURED, 

		or(not(strlen(%1)), and(gte(%1, 1), isint(%1))), 
		#-1 PLACE NUMBER NOT VALID, 

		[setr(n, 
			if(strlen(%1),
				%1, 
				u(f.lowest-available-number, 
					iter(lattr(%0/places.*.details), elements(%i0, 2, .))
				)
			)
		)]
		[trigger(%!/tr.newplace, %0, %qn)]
	)

--

&action.newplace Places Global Object=case(0, or(strmatch(%#, owner(%0)), isstaff(%#)), #-1 SET MAY BE USED BY ROOM OWNER ONLY, hasattr(%0, places.1.details), #-1 PLACES NOT CONFIGURED, or(not(strlen(%1)), and(gte(%1, 1), isint(%1))), #-1 PLACE NUMBER NOT VALID, [setr(n, if(strlen(%1), %1, u(f.lowest-available-number, iter(lattr(%0/places.*.details), elements(%i0, 2, .)))))][trigger(%!/tr.newplace, %0, %qn)])


--------------------------------------------------------------------------------
-- places(): del place ---------------------------------------------------------

Deletes a place, unless someone is already there.

	places(delplace, <room>, <specific place number>)

Returns: #-1 ERROR or ex-place #, if successful.

--

&action.delplace Places Global Object=
	case(0, 
		or(strmatch(%#, owner(%0)), isstaff(%#)), 
		#-1 SET MAY BE USED BY ROOM OWNER ONLY, 

		hasattr(%0, places.1.details), 
		#-1 PLACES NOT CONFIGURED, 

		hasattr(%0, places.%1.details), 
		#-1 PLACE NUMBER NOT VALID, 

		dec(%1), 
		#-1 CANNOT DELETE PLACE #1, 

		not(hasattr(%0, places.%1.occupancy)), 
		#-1 PLACE IS OCCUPIED, 

		%1
		[trigger(%!/tr.delplace, %0, %1)]
	)

--

&action.delplace Places Global Object=case(0, or(strmatch(%#, owner(%0)), isstaff(%#)), #-1 SET MAY BE USED BY ROOM OWNER ONLY, hasattr(%0, places.1.details), #-1 PLACES NOT CONFIGURED, hasattr(%0, places.%1.details), #-1 PLACE NUMBER NOT VALID, dec(%1), #-1 CANNOT DELETE PLACE #1, not(hasattr(%0, places.%1.occupancy)), #-1 PLACE IS OCCUPIED, %1[trigger(%!/tr.delplace, %0, %1)])


--------------------------------------------------------------------------------
-- places(): set ---------------------------------------------------------------

Set an aspect of an existing place (including "gatherings", when exists).

	places(set, <room>, <place #>, <element> , <info>)

Info cannot be null.

qn: element name
qe: possible error during set

--

&action.set Places Global Object=
	case(0, 
		or(strmatch(%#, owner(%0)), isstaff(%#)), 
		#-1 SET MAY BE USED BY ROOM OWNER ONLY, 

@@ >> check that it's set up
		hasattr(%0, places.1.details), 
		#-1 PLACES NOT CONFIGURED, 

@@ >> rudamentary '<place>' check
		hasattr(%0, places.%1.details), 
		#-1 NO SUCH PLACE, 

@@ >> '<info> check
		comp(%3, ), 
		#-1 ELEMENT MAY NOT BE NULL, 

@@ >> '<element>' check - grab full item name & check null
		t(setr(n, 
			grab(
				|[iter(lattr(%!/f.set.*), last(%i0, .), , |)], 
				%2*, |
			)
		)), 
		#-1 ELEMENT NOT FOUND, 

@@ >> '<element>' grabbed was null
		comp(%qn, ), 
		#-1 ELEMENT NOT FOUND, 

@@ >> validate input
		not(strlen(setr(e, u(f.validate.%qn, %3)))), 
		#-1 [ucstr(%qe)], 

@@ >> set, check error from set
		comp(setr(e, u(f.set.%qn, %0, %1, %3)), ), 
		1, 

		#-1 [ucstr(%qe)]
	)

--

&action.set Places Global Object=case(0, or(strmatch(%#, owner(%0)), isstaff(%#)), #-1 SET MAY BE USED BY ROOM OWNER ONLY, hasattr(%0, places.1.details), #-1 PLACES NOT CONFIGURED, hasattr(%0, places.%1.details), #-1 NO SUCH PLACE, comp(%3, ), #-1 ELEMENT MAY NOT BE NULL, t(setr(n, grab(|[iter(lattr(%!/f.set.*), last(%i0, .), , |)], %2*, |))), #-1 ELEMENT NOT FOUND, comp(%qn, ), #-1 ELEMENT NOT FOUND, not(strlen(setr(e, u(f.validate.%qn, %3)))), #-1 [ucstr(%qe)], comp(setr(e, u(f.set.%qn, %0, %1, %3)), ), 1, #-1 [ucstr(%qe)])


--------------------------------------------------------------------------------
-- places(): join --------------------------------------------------------------

If I'm going to make this a function-based system, I might as well go all the way.

	places(join, <room>, <place #>, <player name or dbref>)

qp: dbref from pmatch()
qo: current place occupancy list
qs: spaces (max)
qe: possible error from set

--

&action.join Places Global Object=
	case(0, 
		and(
			strmatch(%0, loc(setr(p, pmatch(%2)))), 
			or(strmatch(%0, loc(%qp)), isstaff(%#))
		), 
		#-1 JOIN MUST BE TRIGGERED BY PLAYER FOR THAT ROOM, 

@@ >> check that it's set up
		hasattr(%0, places.1.details), 
		#-1 PLACES NOT CONFIGURED, 

@@ >> if room is set halt, join/leave can't be cleaned up
		not(hasflag(%0, HALT)), 
		#-1 JOIN CANNOT BE USED IF ROOM IS SET HALT, 

@@ >> rudamentary '<place>' check
		hasattr(%0, places.%1.details), 
		#-1 NO SUCH PLACE, 

@@ >> any space left? (0 spaces = infinite)
		or(
			eq(setr(s, u(f.get.spaces, %0, %1)), 0), 
			lt(
				words(setr(o, u(f.get.occupancy, %0, %1))), 
				%qs
			)
		), 
		#-1 NO SPACES AVAILABLE, 

@@ >> already there
		not(match(%qo, %qp)), 
		#-1 ALREADY AT THAT LOCATION, 

@@ >> dbref has to be player (c.f. pmatch), add it to .occupancy
		comp(setr(e, u(f.set.occupancy, %0, %1, trim(%qo %qp))), ), 
@@ .. ojoin
		[pemit(
			setdiff(lcon(%0), %qo %qp), 
			[name(%qp)] [u(f.display.element, %0, %1, ojoin)]
		)]
@@ .. join
		[pemit(
			setinter(lcon(%0), %qo %qp), 
			[name(%qp)] [u(f.display.element, %0, %1, join)]
		)]
		[pemit(%qp, 
			You join [u(f.display.element, %0, %1, name)] (#%1).
		)]
		1, 

@@ .. error found on set
		#-1 [ucstr(%qe)]
	)

--

&action.join Places Global Object=case(0, and(strmatch(%0, loc(setr(p, pmatch(%2)))), or(strmatch(%0, loc(%qp)), isstaff(%#))), #-1 JOIN MUST BE TRIGGERD PLAYER FOR THAT ROOM, hasattr(%0, places.1.details), #-1 PLACES NOT CONFIGURED, not(hasflag(%0, HALT)), #-1 JOIN CANNOT BE USED IF ROOM IS SET HALT, hasattr(%0, places.%1.details), #-1 NO SUCH PLACE, or(eq(setr(s, u(f.get.spaces, %0, %1)), 0), lt(words(setr(o, u(f.get.occupancy, %0, %1))), %qs)), #-1 NO SPACES AVAILABLE, not(match(%qo, %qp)), #-1 ALREADY AT THAT LOCATION, comp(setr(e, u(f.set.occupancy, %0, %1, trim(%qo %qp))), ), [pemit(setdiff(lcon(%0), %qo %qp), [name(%qp)] [u(f.display.element, %0, %1, ojoin)])][pemit(setinter(lcon(%0), %qo %qp), [name(%qp)] [u(f.display.element, %0, %1, join)])][pemit(%qp, You join [u(f.display.element, %0, %1, name)] (#%1).)]1, #-1 [ucstr(%qe)])


--------------------------------------------------------------------------------
-- places(): whichplace --------------------------------------------------------

Which place# is someone in?  Only available to person in that location. Returns the lowest numbered place, in the incorrect event that the person has joined more than one place.  (This incorrect situation would get fixed via the leave/cleanup code.)

Be Careful: Whichplace has its own validation check.  (If we check for dark players, here's where it should go.)

	places(whichplace, <loc>, <person>)

qn: place number (localized)

--

&action.whichplace Places Global Object=
localize(
	case(0, 
		or(strmatch(setr(p, pmatch(%1)), %#), isstaff(%#)), 
		#-1 WHICHPLACE MUST BE TRIGGERED BY TARGET, 

		t(setr(n, first(sort(u(f.get-num-by-player, %0, %qp))))), 
		#-1 NOT AT ANY PLACE, 

		%qn
	)
)

--

&action.whichplace Places Global Object=localize(case(0, or(strmatch(setr(p, pmatch(%1)), %#), isstaff(%#)), #-1 WHICHPLACE MUST BE TRIGGERED BY TARGET, t(setr(n, first(sort(u(f.get-num-by-player, %0, %qp))))), #-1 NOT AT ANY PLACE, %qn))


--------------------------------------------------------------------------------
-- places(): nameplace ---------------------------------------------------------

Returns the place number of a place's name, the name -> num version of 'whichplace', but returns the place number of all matching places.

	places(nameplace, <loc>, <name>)

qn: place numbers (localized)

--

&action.nameplace Places Global Object=
localize(
	case(0, 
		or(strmatch(%0, loc(%#)), isstaff(%#)), 
		#-1 NAMEPLACE MUST BE USED IN ROOM, 

		t(setr(n, sort(u(f.get-num-by-name, %0, %1)))), 
		#-1 NO MATCH, 

		crumple(%qn)
	)
)

--

&action.nameplace Places Global Object=localize(case(0, or(strmatch(%0, loc(%#)), isstaff(%#)), #-1 NAMEPLACE MUST BE USED IN ROOM, t(setr(n, sort(u(f.get-num-by-name, %0, %1)))), #-1 NO MATCH, crumple(%qn)))


--------------------------------------------------------------------------------
-- places(): depart ------------------------------------------------------------

If I'm going to make this a function-based system, I might as well go all the way.

	places(depart, <room>, <player name or dbref>)

qp: dbref from pmatch()
qn: current place number

qo: new place occupancy list (sans %qp)
qs: spaces (max)
qe: possible error from set

--

&action.depart Places Global Object=
	case(0, 
		or(strmatch(setr(p, pmatch(%1)), %#), isstaff(%#)), 
		#-1 DEPART MUST BE TRIGGERED BY TARGET, 

@@ >> check that it's set up
		hasattr(%0, places.1.details), 
		#-1 PLACES NOT CONFIGURED, 

@@ >> if room is set halt, join/leave can't be cleaned up
		not(hasflag(%0, HALT)), 
		#-1 DEPART CANNOT BE USED IF ROOM IS SET HALT, 

@@ >> check player is at a place - calls 'whichplace'
		t(setr(n, ulocal(action.whichplace, %0, %qp))), 
		%qn, 

@@ >> if the character cleanup is okay...
		not(setr(e, u(action.cleanup, %0, %qp))), 

@@ .. get who's left at that location (edit probably redundant)
		[setq(o, edit(u(f.get.occupancy, %0, %qn), %qp, ))]

@@ .. odepart
		[pemit(
			setdiff(lcon(%0), %qo), 
			[name(%qp)] [u(f.display.element, %0, %qn, odepart)]
		)]
@@ .. depart
		[pemit(
			setinter(lcon(%0), %qo), 
			[name(%qp)] [u(f.display.element, %0, %qn, depart)]
		)]
		1, 

@@ .. error from action.cleanup (already has #-1)
		%qe
	)

--

&action.depart Places Global Object=case(0, or(strmatch(setr(p, pmatch(%1)), %#), isstaff(%#)), #-1 DEPART MUST BE TRIGGERED BY TARGET, hasattr(%0, places.1.details), #-1 PLACES NOT CONFIGURED, not(hasflag(%0, HALT)), #-1 DEPART CANNOT BE USED IF ROOM IS SET HALT, t(setr(n, ulocal(action.whichplace, %0, %qp))), %qn, not(setr(e, u(action.cleanup, %0, %qp))), [setq(o, edit(u(f.get.occupancy, %0, %qn), %qp, ))][pemit(setdiff(lcon(%0), %qo), [name(%qp)] [u(f.display.element, %0, %qn, odepart)])][pemit(setinter(lcon(%0), %qo), [name(%qp)] [u(f.display.element, %0, %qn, depart)])]1, %qe)


--------------------------------------------------------------------------------
-- places(): tt ----------------------------------------------------------------

	places(tt, <loc>, <person>, <msg>, ooc)

qp: dbref of target from pmatch()
qn: current place number

qo: current place occupancy list
qs: say/pose formatted

--


&action.tt Places Global Object=
	case(0, 
		or(and(strmatch(%0, loc(%#)), strmatch(setr(p, pmatch(%1)), %#)), isstaff(%#)), 
		#-1 TT MUST BE USED IN ROOM BY PERSON, 

@@ >> check that it's set up
		hasattr(%0, places.1.details), 
		#-1 PLACES NOT CONFIGURED, 

@@ >> if room is set halt, join/leave can't be cleaned up
		not(hasflag(%0, HALT)), 
		#-1 TT CANNOT BE USED IF ROOM IS SET HALT, 

@@ >> check player is at a place - calls 'whichplace'
		t(setr(n, ulocal(action.whichplace, %0, %qp))), 
		%qn, 

@@ >> talk away
		[setq(o, u(f.get.occupancy, %0, %qn))]
		[setq(p, name(%qp))]
		[setq(s, 
			objeval(%#, switch(
				%2, 
				:*, %qp [rest(%2, :)], 
				%;*, %qp[rest(%2, %;)], 
				|*, [rest(%2, |)] [ansi(xh, <from %qp>)], 
				"*, %qp says%, “[rest(%2, ")]”, 
				%qp says%, “%2”
			))
		)]
		[case(1, 
@@ .. >> staff evesdropping?

@@ .. >> ooc?
			strmatch(%3, ooc), 
			pemit(%qo, 
				[u(f.display.element, %0, %qn, say_prefix)]%, 
				[ansi(xh, <ooc>)]%, %qs
			), 

@@ .. >> normal
			pemit(%qo, [u(f.display.element, %0, %qn, say_prefix)] %qs)
		)]
		1

	)

--

&action.tt Places Global Object=case(0, or(and(strmatch(%0, loc(%#)), strmatch(setr(p, pmatch(%1)), %#)), isstaff(%#)), #-1 TT MUST BE USED IN ROOM BY PERSON, hasattr(%0, places.1.details), #-1 PLACES NOT CONFIGURED, not(hasflag(%0, HALT)), #-1 TT CANNOT BE USED IF ROOM IS SET HALT, t(setr(n, ulocal(action.whichplace, %0, %qp))), %qn, [setq(o, u(f.get.occupancy, %0, %qn))][setq(p, name(%qp))][setq(s, objeval(%#, switch(%2, :*, %qp [rest(%2, :)], %;*, %qp[rest(%2, %;)], |*, [rest(%2, |)] [ansi(xh, <from %qp>)], "*, %qp says%, “[rest(%2, ")]”, %qp says%, “%2”)))][case(1, strmatch(%3, ooc), pemit(%qo, [u(f.display.element, %0, %qn, say_prefix)] [ansi(xh, <ooc>)]%, %qs), pemit(%qo, [u(f.display.element, %0, %qn, say_prefix)]%, %qs))]1)


---------------------------------------------------------------------------------- places(): get ---------------------------------------------------------------

A complement to 'set' for people who want to have the place description added to the room description.  Don't error if no such place, just return null.  (This is non-standard behavior, but more end-user friendly.)

	places(get, <loc>, <place>, <element>)

e.g., on @succ: places(get, %!, places(whichplace, %!, %#), description)

qe: element from 'f.get'.

--

&action.get Places Global Object=
	case(0, 
		or(strmatch(%0, loc(%#)), isstaff(%#)), 
		#-1 GET MUST BE USED IN ROOM, 

@@ >> check that it's set up
		hasattr(%0, places.1.details), 
		#-1 PLACES NOT CONFIGURED, 

@@ >> don't error if no such place, but do error if no such element
		comp(setr(e, u(f.get, %0, %1, %2)), #-1), 
		#-1 NO SUCH ELEMENT, 

		%qe
	)

--

&action.get Places Global Object=case(0, or(strmatch(%0, loc(%#)), isstaff(%#)), #-1 GET MUST BE USED IN ROOM, hasattr(%0, places.1.details), #-1 PLACES NOT CONFIGURED, comp(setr(e, u(f.get, %0, %1, %2)), #-1), #-1 NO SUCH ELEMENT, %qe)


