================================================================================
== PLANNING: Old Places ========================================================

* mv from <#> to <#> Moves a vacancy from one place to another.                                                                              
* join <place name> Puts you at <place name>                                                                                                 
* join at #<num> Puts you at place #<num>.                                                                                                   
* join with <name> Puts you at the place with <name>.                                                                                        
* depart Removes you from your place.                                                                                                        
* sit * Alias for Join.                                                                                                                      
* depart Removes you from your place.                                                                                                        
* places Lists who's present at all places.                                                                                                  
* place <num> Lists who's present at place <num>.                                                                                            
* plook Lists in column format everyone around the room.                                                                                     
* plook <num> Lists name of <num> and virtual desc.                                                                                          
* tt <message> (Tete a tete) Relays a message to all those at your place. This command takes the usual say/pose tokens, and TT |<message>    
  will emit.                                                                                                                                   
* ttooc <message> (Tete a tete) Relays an OOC message                                                                                        
* update <#>/<Option>=<text> See "+help places-options"                                                                                      

PLACES are virtual places to sit, stand or occupy. You remain in the same room, but join a group of people within that room who may or may not be having a quiet conversation only with others placed with them.

For installation help, see "places-config".

--

Update <Place #>/<Option>=<Configuration Text>

Option Description - <Option> - Default Configuration Text
* Place Name - NAME - Table x                                                                                                                
* Maximum # of places - MAXPLACES - Random                                                                                                   
* Current # of places - CURPLACES - Random (1 >= # >= MAXPLACES)                                                                             
* Fixed fail message - FIXED - <NULL>                                                                                                        
* Full fail message - FULL - That table has no more room.                                                                                    
* Join message - JOIN - You sit down at <place>.                                                                                             
* Ojoin message - OJOIN - sits down at <place>.                                                                                              
* Depart message - DEPART - You stand and leave <place>.                                                                                     
* Odepart message - ODEPART - stands and leaves <place>.                                                                                     
* Say prefix - PREFIX - At your table                                                                                                        
* Description - DESCRIBE - A table with 4 legs and some chairs                                                                              

--

This code originally provided courtesy of Deirdre, Meg, and Osric of AmberMUSH. It has since been edited by Angel@Heaven

* Configure <num> places                                                                                                                     
* Unconfigure places                                                                                                                         

Notes: A null fixed message means vacancies can be moved freely to and from the place. This does not make sense for things like couches and rugs. Set it to something like "That makes no sense." if you are using such a place.

(O)Join and (O)depart messages take like this: %N. All Join and Depart messages are appended with the place name.

Functions:
* WHICHPLACE(<loc num>,<dbnum>) gives the number of a place where <dbnum> is.                                                                
* ATPLACE(<loc num>,<place num>) gives you a list of things at a place.                                                                      
* PLACEINFO(<loc num>,<place num>,<option>) gives the value of <option> at place.                                                           



think [setq(w, whichplace)][setq(c, yh)][list(search(eval=grepi(##, *, %qw)), [wheader([name(%i0)] %(%i0%))]%r[iter(grepi(%i0, *, %qw), [ansi(%qc, >> %i0 <<)]%r[edit(get(%i1/%i0), %qw, ansi(%qc, %qw))], , %r)])][wfooter()]


================================================================================
== PLANNING: Setting Up Places =================================================

The owner of a location should be able to set up places there, but the concept of "owner" is sometimes an iffy one.  Some games prefer that staff own all public hangouts, for example, even though a noncharbit has administrative control over it.

We'll store everything, including this optional 'places owner' lock, on a set of room attributes prefixed &places.* & keep controlled information locked to the places object.

	places.<num>.details: <name>|<spaces total>|<description>
	places.<num>.notices: 
		<say prefix>|<osay prefix>|<join>|<ojoin>|<depart>|<odepart>
	places.<num>.occupancy: <who's there>

(If 'spaces total' is 0, no limit.)

If we get this far, lock to the places system object:

	places.administrators: <list of people who can set up places here>

User-defined commands we'll need:

	isstaff(<player>) - return '1' if player has staff access
	lmin(<list> [, <delimiter>]) - min() with delimiter

	header(<text>) - game's default command header
	footer(<text>) - game's default command footer
	divider() - minor divider
	alert(<test>) - header for informational alerts


--------------------------------------------------------------------------------
-- As-Needed Places (LA's Gatherings) ------------------------------------------

*** TO DO ***

You could, essentially, 'go stand next to' someone and it'd make the place spontaneously and other people could join it.

And it ceases to be when all are gone.

Same, but &gathering.* (?) -- no, because the rest of the places system needs to be able to interface with it.

Instead: &place.<# of places + 1> and 
		 &_gatherings: <list of place numbers that are gatherings>



================================================================================
== SETUP: Places ===============================================================

@create Places Global Object <pgo>
@set pgo=Inherit
@set pgo=Safe

@parent pgo=Code Object Data Parent <codp>
&prefix.user_function_actions pgo=action.


================================================================================
== PLACES GLOBAL OBJECT <pgo> ==================================================

Commands:

	places - the main driving command
	tt[ooc] - tabletalk
	sit/join & depart/leave - there we go

NOTE TO SELF: I think the 'mutter' commands try to integrate with the places systems.  Remember to check and fix accordingly.


--------------------------------------------------------------------------------
-- Data ------------------------------------------------------------------------

None so far.


--------------------------------------------------------------------------------
-- Mistress Setup --------------------------------------------------------------

The "Mistress System" funnels everything through a single command.  For this command, like many others, an optional 's' on it is valid.  e.g., +place/+places.  (I should regexp that.)

	+command(s) -> &c.<command>.default
	+command(s) <stuff> -> &c.<command>.specific
	+command(s)/switches [<stuff>] -> &c.<command>/<switch>

To each of these (including the first), the following are passed:
	%0: <stuff>
	%1: </other/switches>

In the case of the switches, the first valid switch has their command called, if all switches are invalid we call &c.<name>.default or &c.<name>.specific, depending on the above rules.

--

&c.places Places Global Object=$place*:@pemit %#=
	[setq(n, places)]
	[switch(%0, 
@@ Without 's' ending
		, u(c.%qn.default), 
		/*, u(c.%qn.switch, first(%0), rest(%0)), 
		%b*, u(c.%qn.specific, trim(%0)), 

@@ With 's' ending
		s, u(c.%qn.default), 
		s/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), 
		s%b*, u(c.%qn.specific, trim(rest(%0))), 

@@ No match
		Error: I don't know what you mean. Please see [ansi(h, +help %qn)]
	)]

--

&c.places Places Global Object=$+place*:@pemit %#=[setq(n, places)][switch(%0, , u(c.%qn.default), /*, u(c.%qn.switch, first(%0), rest(%0)), %b*, u(c.%qn.specific, trim(%0)), s, u(c.%qn.default), s/*, u(c.%qn.switch, /[first(after(%0, /))], rest(%0)), s%b*, u(c.%qn.specific, trim(rest(%0))), Error: I don't know what you mean. Please see [ansi(h, +help %qn)])]


--------------------------------------------------------------------------------
-- +places/<switch> ------------------------------------------------------------

Handles all /switches, which is to say it makes sure they exist and passes them on.

Also handles pseudo-switches, passing them on as elements to any switched item.

Passes to &c.<name>.specific (%1, %qp) or &c.<name>/<switch> (%1, %qp), even if %1 is empty.

--

0: /<switch>[/<switch>/<switch>, etc.]
1: [<more>], stuff to pass to c.<name>/<switch>, if any
qn: Name of the command, global register set in &c.<name> (above)

qa: all c.<name>/* on this object
qs: /valid/command/switches/found
qp: /pseudo/switches/found, pass to c.<name>[/<switch>]

--

&c.places.switch Places Global Object=
	[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))]
	[iter(rest(%0, /), 
		if(
			t(grab(%qa, c.%qn/%i0*)), 
			setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), 
			setq(p, %qp/%i0)
		), 
		/, @@
	)]
	[if(t(%qs), 
		ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), 
		if(t(%1), 
			ulocal(c.%qn.specific, %1, %qp), 
			ulocal(c.%qn.default, %1, %qp)
		)
	)]

--

&c.places.switch Places Global Object=[setq(s, )][setq(p, )][setq(a, lattr(%!/c.%qn/*))][iter(rest(%0, /), if(t(grab(%qa, c.%qn/%i0*)), setq(s, %qs/[rest(grab(%qa, c.%qn/%i0*), /)]), setq(p, %qp/%i0)), /, @@)][if(t(%qs), ulocal(c.%qn/[extract(%qs, 2, 1, /)], %1, %qp), if(t(%1), ulocal(c.%qn.specific, %1, %qp), ulocal(c.%qn.default, %1, %qp)))]


--------------------------------------------------------------------------------
-- places (default) ------------------------------------------------------------

Show default places setup.

0: ignored
1: fake /switches, ignored

ql: location of %#

--

&c.places.default Places Global Object=
	case(0, 
		attrcnt([setr(l, loc(%#))]/places.*.details), There are no places here., 
		list(
			lattr(%ql/places.*.details), 
			u(f.display.one-place, %ql, %i0)
		)
	)

--

&c.places.default Places Global Object=case(0, attrcnt([setr(l, loc(%#))]/places.*.details), There are no places here., list(lattr(%ql/places.*.details), u(f.display.one-place, %ql, %i0)))


--------------------------------------------------------------------------------
-- places <stuff> (specific) ---------------------------------------------------

Show information about a particular place

0: place name or number
1: fake /switches, ignored

ql: location of %#
qn: number of location, if name passed

--

&c.places.default Places Global Object=
	case(1, 
		not(attrcnt([setr(l, loc(%#))]/places.*.details)), 
		There are no places here., 

		isint(%0), u(f.display.one-place, %ql, %0), 
		
		t(setr(n, u(f.get-num-by-name, %ql, %0))), 
		u(f.display.one-place, %ql, %qn), 
		
		[alert(+places)] I can't find that place.
	)

--

&c.places.default Places Global Object=case(1, not(attrcnt([setr(l, loc(%#))]/places.*.details)), There are no places here., isint(%0), u(f.display.one-place, %ql, %0), t(setr(n, u(f.get-num-by-name, %ql, %0))), u(f.display.one-place, %ql, %qn), [alert(+places)] I can't find that place.)



================================================================================
== FUNCTION: Get XXX ===========================================================

A bunch of functions to get specific information.  An easy way to get information for current and future coding.

	u(f.get, <loc>, <placenum>, <list|of|elements>)
	u(f.get.<element>, <loc>, <placenum>, <element>)

--

&f.get pgo=iter(%3, udefault(grab(lattr(%!/f.get.%i0*)), #-1, %0, %1), |, |)

&f.get.name pgo=u(f.get-element, %0, details, %1, 1, %2, name)
&f.get.spaces_total pgo=u(f.get-element, %0, details, %1, 2, %2, spaces)
&f.get.description pgo=u(f.get-element, %0, details, %1, 3, %2, description)

&f.get.say_prefix pgo=elements(get(%0/places.%1.notices), 1, |)
&f.get.osay_prefix pgo=u(f.get-element, %0, notices, %1, 2, %2, osay_prefix)
&f.get.join pgo=u(f.get-element, %0, notices, %1, 3, %2, join)
&f.get.ojoin pgo=u(f.get-element, %0, notices, %1, 4, %2, ojoin)
&f.get.depart pgo=u(f.get-element, %0, notices, %1, 5, %2, depart)
&f.get.odepart pgo=u(f.get-element, %0, notices, %1, 6, %2, odepart)

&f.get.occupancy pgo=get(%0/places.%1.occupancy)

--

0: dbref
1: attribtue data is on
2: place num
3: location in attribute
4: name of item (for pulling default)

&f.get-element pgo=localize(
	[setq(e, elements(get(%0/places.%2.%1), %3, |))]
	[if(strlen(%qe), objeval(%0, s(%qe)), v(d.default.%4))]
)


--------------------------------------------------------------------------------
-- Function: Get Num By Name ---------------------------------------------------

Slightly related, getting the number for a particular named place is critical.  
Normally I use the name for the key, but for this system we're using the place
number.

Cheap filter().

--

&f.get-num-by-name pgo=elements(first(iter(lattr(%0/places.*.details), if(strmatch(first(get(%0/%i0), |), %1*), %i0))), 2, .)


================================================================================
== FUNCTIONS: Set XXX ==========================================================

Replaces elements entirely.  No checking first; using this on a place that hasn't been set up first will cause the information to not be written, due to the nature of replace() on TinyMUX.

	u(f.set.<element>, <loc>, <placenum>, <item>)

--

&f.set.name pgo=u(f.set-element, %0, details, %1, 1, %2)
&f.set.spaces_total pgo=u(f.set-element, %0, details, %1, 2, %2)
&f.set.description pgo=
	set(%0, 
		places.%1.details:
		[elements(get(%0/places.%1.details), 1 2, |, |)]|%1]
	)

&f.set.say_prefix pgo=u(f.set-element, %0, notices, %1, 1, %2)
&f.set.osay_prefix pgo=u(f.set-element, %0, notices, %1, 2, %2)
&f.set.join pgo=u(f.set-element, %0, notices, %1, 3, %2)
&f.set.ojoin pgo=u(f.set-element, %0, notices, %1, 4, %2)
&f.set.depart pgo=u(f.set-element, %0, notices, %1, 5, %2)
&f.set.odepart pgo=u(f.set-element, %0, notices, %1, 6, %2)

&f.set.occupancy pgo=set(%0, places.%1.occupancy:%1)

--

0: dbref
1: attribtue data is on
2: place num
3: location in attribute
4: new value

&f.set-element pgo=set(%0, places.%2.%1:[replace(get(%0/places.%2.%1), %3, %4, |)])


================================================================================
== DATA: Defaults ==============================================================

If a places element is not set, or while setting up, use these defaults.

&d.default.name pgo=A Table
&d.default.spaces_total pgo=5
&d.default.description pgo=A table with a couple of chairs.

&d.default.say_prefix pgo=At your table,
&d.default.osay_prefix pgo=From #NAME (#LOC),
&d.default.join pgo=joins your location.
&d.default.ojoin pgo=sits at #NAME (#LOC).
&d.default.depart pgo=leaves your location.
&d.default.odepart pgo=leaves #NAME (#LOC).



================================================================================
== DISPLAY: One Place ==========================================================

Used by 'show me information about all places/one place'

Old:
Table 1 (#1) has 2 empty places.
        Present is:  Thenomain.

New:
	same for now, with spaces_total of '0' == '(no limit)'

0: location dbref
1: place number

--

&f.display.one-place Places Global Object=<xxx>


================================================================================
== DISPLAY: Elements ===========================================================

The output of the various elements.

--------------------------------------------------------------------------------
-- Display Element -------------------------------------------------------------

Output any known element.  Edit any tokens in the text.

0: dbref
1: place
2: element

--

&f.display.element pgo=
	edit(
@@ .. get element - we know we'll get something if valid
		udefault(
			f.display.element.%2, 
			u(f.display.element.other, %0, %1, %2), 
			%0, %1, %2
		), 
@@ .. replace tokens
		#LOC, <location number>, 
		#NAME, <location name>
	)

--

&f.display.element pgo=edit(udefault(f.display.element.%2, u(f.display.element.other, %0, %1, %2), %0, %1, %2), #LOC, <location number>, #NAME, <location name>)


--------------------------------------------------------------------------------
-- Elements to display ---------------------------------------------------------

&f.display.element.other pgo=udefault(f.get.%2, #-1 Element Unknown, %0, %1)

&f.display.element.occupancy pgo=itemize(iter(u(f.get.occupancy), name(%i0), , |), |)


================================================================================
== TRIGGER: Setup ==============================================================

The room setup functions.  Since someone can run some of these multiple times, we'll unlock things that we lock first.

Setting up WILL clobber a room's @adisconnect, @aleave, and @startup

0: Our target room.

--

&tr.setup Places Global Object=
	@unlock %0/adisconnect; 
	@unlock %0/aleave; 
	@unlock %0/startup; 

	@adisconnect %0=places(%%!, cleanup); 
	@aleave %0=places(%%!, cleanup); 
	@startup %0=places(%%!, cleanup); 

	@chown %0/adisconnect=[owner(%0)]; 
	@chown %0/aleave=[owner(%0)]; 
	@chown %0/startup=[owner(%0)]; 

	@lock %0/adisconnect=%0; 
	@lock %0/aleave=%0; 
	@lock %0/startup=%0; 

--

&tr.setup Places Global Object=@unlock %0/adisconnect; @unlock %0/aleave; @unlock %0/startup; @adisconnect %0=places(%%!, cleanup); @aleave %0=places(%%!, cleanup); @startup %0=places(%%!, cleanup); @chown %0/adisconnect=[owner(%0)]; @chown %0/aleave=[owner(%0)]; @chown %0/startup=[owner(%0)]; @lock %0/adisconnect=%0; @lock %0/aleave=%0; @lock %0/startup=%0; 

================================================================================
== TRIGGER: Breakdown ==========================================================

The places removal function.

This WILL clobber a room's @adisconnect, @aleave, and @startup

0: Our target room.

--

&tr.breakdown Places Global Object=
	@unlock %0/adisconnect; 
	@unlock %0/aleave; 
	@unlock %0/startup; 

	@adisconnect %0=; @aleave %0=; @startup %0=; 

	@dolist [lattr(%0/places.*)]={&## %0=}; 

--

&tr.breakdown Places Global Object=@unlock %0/adisconnect; @unlock %0/aleave; @unlock %0/startup; @adisconnect %0=; @aleave %0=; @startup %0=; @dolist [lattr(%0/places.*)]={&## %0=}; 


================================================================================
== TRIGGER: New Place ==========================================================

Sets up Place #%1 in room %0 with all the defaults.

--

&tr.newplace Places Global Object=
	&places.%1.details %0=[iter(name spaces_total description, v(d.default.%i0), , |)];
	&places.%1.notices %0=[iter(say_prefix osay_prefix join ojoin depart odepart, v(d.default.%i0), , |)]; 
	@chown %0/places.%1.details=[owner(%0)]; 
	@chown %0/places.%1.notices=[owner(%0)]; 

--

&tr.newplace Places Global Object=&places.%1.details %0=[iter(name spaces_total description, v(d.default.%i0), , |)];&places.%1.notices %0=[iter(say_prefix osay_prefix join ojoin depart odepart, v(d.default.%i0), , |)]; @chown %0/places.%1.details=[owner(%0)]; @chown %0/places.%1.notices=[owner(%0)]; 


================================================================================
== FUNCTIONS: Support Functions ================================================

Some functions used for various different aspects of the system.


--------------------------------------------------------------------------------
-- Lowest Available Number -----------------------------------------------------

Passed a list of integers, it will return the lowest available positive integer.

0: list of values

&f.lowest-available-number pgo=lmin(setdiff(%0, lnum(1, lmax(%0))))


================================================================================
== USER DEFINED FUNCTIONS: Support Functions ===================================

REMEMBER TO HOOK THIS INTO WHATEVER YOUR USER-DEFINED FUNCTION SETUP IS!


--------------------------------------------------------------------------------
-- places() --------------------------------------------------------------------

Rather than have one function per item, let's just have one function.

	places(<action>, <room> [, <other>])

--

&ufunc.places Places Global Object=
	[setq(l, locate(%#, %1, ahR))]
	[if(and(t(%ql), hastype(%ql, ROOM)), 
		udefault(action.%0, #-1 ACTION NOT FOUND, %ql, %2, %3, %4), 
		#-1 ROOM NOT FOUND
	)]

--

&ufunc.places Places Global Object=[setq(l, locate(%#, %1, ahR))][if(and(t(%ql), hastype(%ql, ROOM)), udefault(action.%0, #-1 ACTION NOT FOUND, %ql, %2, %3, %4), #-1 ROOM NOT FOUND)]


--------------------------------------------------------------------------------
-- places(): list --------------------------------------------------------------

List places in the room and who is at it, or list everyone in a certain place.

List is available only to the room itself, people in the room, or to a staffer.

(note: I'm using isstaff(%#), but for parent room setups it may be better to use isstaff(%@))

	places(list, <room> [, <place>])

Returns: #-1 ERROR or '<place name> (<num>):<list of dbrefs there>', |-delim

--

&action.list Places Global Object=
	case(0, 
		or(strmatch(%0, %@), strmatch(%0, loc(%#)), isstaff(%#)), 
		#-1 LIST MUST BE USED IN ROOM OR BY ROOM, 

@@ >> no '<place>', return everything, may be null
		comp(%1, ), 
		iter(lattr(%0/places.*.details), 
@@ .. less efficient than grabbing directly from attribute, more updatable 
			[setq(n, elements(%i0, 2, .))]
			[u(f.get.name, %0, %qn, name)] (%qn):
			[u(f.get.occupancy, %0, %qn)], 
			, |
		), 

@@ >> rudamentary '<place>' check
		hasattr(%0, places.%1.details), 
		#-1 NO SUCH PLACE, 

@@ >> 'else' assumption: place exists, so show it
		[u(f.get.name, %0, %1, name)] (%qn):[u(f.get.occupancy, %0, %1)]
	)

--

&action.list Places Global Object=case(0, or(strmatch(%0, %@), strmatch(%0, loc(%#)), isstaff(%#)), #-1 LIST MUST BE USED IN ROOM OR BY ROOM, comp(%1, ), iter(lattr(%0/places.*.details), [setq(n, elements(%i0, 2, .))][u(f.get.name, %0, %qn, name)] (%qn):[u(f.get.occupancy, %0, %qn)], , |), hasattr(%0, places.%1.details), #-1 NO SUCH PLACE, [u(f.get.name, %0, %1, name)] (%qn):[u(f.get.occupancy, %0, %1)])


--------------------------------------------------------------------------------
-- places(): cleanup -----------------------------------------------------------

Cleanup is available only to the room itself, people in the room, or to a staffer.

NOTE: Remember to scan for/clean null "gatherings" when it's installed.

	places(cleanup, <room> [, <dbrefs to remove>])

Returns: #-1 ERROR or 1 (true) if the code ran or set without error.

--

&action.cleanup Places Global Object=
	case(0, 
		or(strmatch(%0, %@), strmatch(%0, loc(%#)), isstaff(%#)), 
		#-1 CLEANUP MUST BE USED IN ROOM OR BY ROOM, 

		or(strmatch(%1, ), strmatch(%1, %#), strmatch(%0, %@), isstaff(%#)), 
		#-1 CLEANUP PLAYER MUST BE USED BY PLAYER OR ROOM, 

@@ no specific dbref(s), clean up everyone
		comp(%1, ), 
		[setq(c, lcon(loc(%#), connect))]
		[setq(e, 
			iter(lattr(%0/places.*.occupancy), 
				set(%0, %i0:[setunion(get(%0/%i0), %qc)]), , @@
			)
		)]
		[if(comp(%qe, ), 
			#-1 [ucstr(%qe)], 
			1
		)], 

@@ specific dbref(s), clean up only them
		[setq(e, 
			iter(lattr(%0/places.*.occupancy), 
				set(%0, %i0:[setdiff(get(%0/%i0), %1)]), , @@
			)
		)]
		[if(comp(%qe, ), 
			#-1 [ucstr(%qe)], 
			1
		)], 
		
		#-1 FUNCTION PANIC IN 'CLEANUP'
	)

--

&action.cleanup Places Global Object=case(0, or(strmatch(%0, %@), strmatch(%0, loc(%#)), isstaff(%#)), #-1 CLEANUP MUST BE USED IN ROOM OR BY ROOM, or(strmatch(%1, ), strmatch(%1, %#), strmatch(%0, %@), isstaff(%#)), #-1 CLEANUP PLAYER MUST BE USED BY PLAYER OR ROOM, comp(%1, ), [setq(c, lcon(loc(%#), connect))][setq(e, iter(lattr(%0/places.*.occupancy), set(%0, %i0:[setunion(get(%0/%i0), %qc)]), , @@))][if(comp(%qe, ), #-1 [ucstr(%qe)], 1)], [setq(e, iter(lattr(%0/places.*.occupancy), set(%0, %i0:[setdiff(get(%0/%i0), %1)]), , @@))][if(comp(%qe, ), #-1 [ucstr(%qe)], 1)], #-1 FUNCTION PANIC IN 'CLEANUP')


--------------------------------------------------------------------------------
-- places(): setup -------------------------------------------------------------

Set (or re-set) up a room.  Clobbers @startup, @aleave, @adisconnect.

Must be used by room owner or staffer.

	places(setup, <room> [, YES])

Returns: #-1 ERROR or 1 if it believes it was successful.

--

&action.setup Places Global Object=
	case(0, 
		or(strmatch(%#, owner(%0)), isstaff(%#)), 
		#-1 SETUP MAY BE USED BY ROOM OWNER ONLY, 

@@ >> 'YES' was passed, do it
		comp(%1, YES), 
		[trigger(%!/tr.setup, %0)]
		[if(
			not(hasattr(%0, places.1.details)), 
			trigger(%!/tr.newplace, %0, %1)
		)]
		1, 

@@ >> else: no 'YES', show warning
		#-1 SETUP REQUIRES CONFIRMATION
	)

--

&action.setup Places Global Object=case(0, or(strmatch(%#, owner(%0)), isstaff(%#)), #-1 SETUP MAY BE USED BY ROOM OWNER ONLY, comp(%1, YES), [trigger(%!/tr.setup, %0)][if(not(hasattr(%0, places.1.details)), trigger(%!/tr.newplace, %0, 1))]1, #-1 SETUP REQUIRES CONFIRMATION)


--------------------------------------------------------------------------------
-- places(): breakdown ---------------------------------------------------------

Remove places from a room permenantly. 

Clobbers @startup, @aleave, @adisconnect.

	places(setup, <room> [, YES])

Returns: #-1 ERROR or 1 if it believes it was successful.

--

&action.breakdown Places Global Object=
	case(0, 
		or(strmatch(%#, owner(%0)), isstaff(%#)), 
		#-1 BREAKDOWN MAY BE USED BY ROOM OWNER ONLY, 

@@ >> 'YES' was passed, do it
		comp(%1, YES), 
		[trigger(%!/tr.breakdown, %0)]
		1, 

@@ >> else: no 'YES', show warning
		#-1 BREAKDOWN REQUIRES CONFIRMATION
	)

--

&action.breakdown Places Global Object=
	case(0, 
		or(strmatch(%#, owner(%0)), isstaff(%#)), 
		#-1 BREAKDOWN MAY BE USED BY ROOM OWNER ONLY, 

		comp(%1, YES), 
		[trigger(%!/tr.breakdown, %0)]
		1, 

		#-1 BREAKDOWN REQUIRES CONFIRMATION
	)
