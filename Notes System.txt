+ NOTES: An Awesome System

PEOPLE LOVE:
	Different view levels
	Let people edit notes, but the validation falls off - using CHOWN attribute
	Timestamp: creation, edit, lock

FORMAT:
	+note[/list/of/switches] <note>[=<other>]

KEY: 
	<note> - <object>/<note>

COMMANDS:

All switches are mutually exclusive unless noted otherwise.  Ignore all mutually exclusive switches except the first, in those cases.

@@ basics (approval falls off using any of these): 
	/new
		Special rules using the +bg alias
			+bg/new [<player>=]<text> - Auto-increment, prepend: BG #
	/add
		appends to a note
	/edit <note>=<old>/<new>
	/replace
		Uses /add, except note must exist
	/delete

@@ moving (approval falls off using any of these): 
	/move <note>=<target>|<new name>|<target>/<new name>
	/clone <note>=<target>|<new name>|<target>/<new name>

@@ locks (stacks with basics and moving, except /delete):
	/[un]apporove
	/[un]lock
		Also /[un]approves.

@@ viewing:
	/view <item>|<note>|<item/note>
		Special rules using the +view alias:
			+view: view here
			+view <item>: view item (processed first)
			+view <note>: view here/note
	/show <note>=<targets>

@@ permissions (approval falls off using any of these unless staff):
	/permissions <note>[=<permission level>]
		view, public
		note, private
		judgenote, staff
		(other use Access System Fob)

		Aliases chould assume permissions level.  e.g.:
			+view/new - public
			+bg/new - private
			+note/new - private
			+judgenote/new - staff


-- SQL Notes -------------------------------------------------------------------

Create a full history system, a la Wikipedia.

SQL DD:
	target'd debref (not null, to validate vs game dbref + _location_ID)
	editor's dbref (primary key)
	timestamp (primary key)
	target's creation timestamp (not null)
		- convtime(get(me/created), , 6)
		- target dbref + creation date = UUID
	the complete new note, even if only edited (not null)
	permissions (default: private)
	approval dbref

--

DROP TABLE IF EXISTS mush_notes; 
CREATE TABLE IF NOT EXISTS mush_notes
(
    target           INT             NOT NULL, 
    editor           INT             NOT NULL, 
    time             TIMESTAMP       NOT NULL, 
    target_created   TIMESTAMP       NOT NULL, 
    title            VARCHAR(255)    NOT NULL, 
    note             TEXT            NOT NULL, 
    permission       VARCHAR(255)    NOT NULL DEFAULT 'private', 
    approved_by      INT, 
    locked_by        INT, 

    PRIMARY KEY (target, editor, time), 
    INDEX target_UUID (target, target_created)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--

@@ Basic insert + optional approve + optional loc
@@ 0: editor dbref, 1: target dbref, 2: title, 3: note, 4: permission, 
@@ 5: approve?, 6: lock?

&sql.insert Notes System=
	INSERT INTO mush_notes 
	VALUES (
		[rest(%1, #)], 
		[rest(%0, #)], 
		NOW(), 
		FROM_UNIXTIME('[convtime(get(%1/created), , 6)]'), 
		'%2', 
		'%3', 
		'[if(t(%4), %4, private)]', 
		[if(t(%5), rest(%0, #), NULL)], 
		[if(t(%6), rest(%0, #), NULL)]
	);

--

@@ List of note titles from a specific person
@@ 0: target dbref
@@ output: target (dbref), editor (dbref), time (secs), 
@@         target_created (secs), title (text), 
@@         permission (text), approved_by (dbref), locked_by (dbref)
@@ (not the note text itself)

&sql.one-dbref Notes System=
	SELECT 
		concat('#', target) AS target, 
		concat('#', editor) AS editor, 
		UNIX_TIMESTAMP(time) AS time, 
		title, 
		permission, 
		IF(IFNULL(approved_by, NULL), concat('#', approved_by), '') AS approved_by, 
		IF(IFNULL(locked_by, NULL), concat('#', locked_by), '') AS locked_by 
	FROM mush_notes 
	WHERE 
		target = [rest(%0, #)] AND 
		target_created = 
			FROM_UNIXTIME('[convtime(get(%0/created), , 6)]');
--

@@ List of a specific person's notes, found by title match
@@ 0: target dbref
@@ output: target (dbref), editor (dbref), time (secs), 
@@         target_created (secs), title (text), 
@@         permission (text), approved_by (dbref), locked_by (dbref)
@@ (not the note text itself)

&sql.one-dbref.title-lookup Notes System=
	SELECT 
		concat('#', target) AS target, 
		concat('#', editor) AS editor, 
		UNIX_TIMESTAMP(time) AS time, 
		title, 
		permission, 
		IF(IFNULL(approved_by, NULL), concat('#', approved_by), '') AS approved_by, 
		IF(IFNULL(locked_by, NULL), concat('#', locked_by), '') AS locked_by 
	FROM mush_notes 
	WHERE 
		target = [rest(%0, #)] AND 
		target_created = 
			FROM_UNIXTIME('[convtime(get(%0/created), , 6)]') AND 
		title LIKE '%1\\\%'
	ORDER BY title ASC;

--

@@ Get the text of a specific note
@@ 0: target dbref, 1: editor dbref, 2: timestamp
@@ (primary key)
@@ output: note text

&sql.primary_key.note_text Notes System=
	SELECT note 
	FROM mush_notes 
	WHERE 
		target = [rest(%0, #)] AND 
		editor = [rest(%1, #)] AND 
		time = FROM_UNIXTIME('%2'); 

--

@@ Find abandoned 'dbref + creation date' UUIDs.

<< REMINDER TO DO >>

--

A DECENT TEST: 

think 
	[setr(r, sql(u(note/sql.one-dbref.title-lookup, %#, tes), ~, |))] ==> 
	t:[setr(t, first(%qr, |))] -- 
	e:[setr(e, elements(%qr, 2, |))] -- 
	s:[setr(s, elements(%qr, 3, |))] ==> 
	[sql(u(notes/sql.primary_key.note_text, %qt, %qe, %qs))]


